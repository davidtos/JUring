// Generated by jextract

package sockets.rawcalls;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class uring_syscalls_h_1 extends uring_syscalls_h_2 {

    uring_syscalls_h_1() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __blksize_t
     * }
     */
    public static final OfInt __blksize_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = uring_syscalls_h.C_INT;

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int access(const char *__name, int __type)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int access(const char *__name, int __type)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int access(const char *__name, int __type)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int access(const char *__name, int __type)
     * }
     */
    public static int access(MemorySegment __name, int __type) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", __name, __type);
            }
            return (int)mh$.invokeExact(__name, __type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int faccessat(int __fd, const char *__file, int __type, int __flag)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int faccessat(int __fd, const char *__file, int __type, int __flag)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int faccessat(int __fd, const char *__file, int __type, int __flag)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int faccessat(int __fd, const char *__file, int __type, int __flag)
     * }
     */
    public static int faccessat(int __fd, MemorySegment __file, int __type, int __flag) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", __fd, __file, __type, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __type, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t lseek(int __fd, __off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t lseek(int __fd, __off_t __offset, int __whence)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t lseek(int __fd, __off_t __offset, int __whence)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t lseek(int __fd, __off_t __offset, int __whence)
     * }
     */
    public static long lseek(int __fd, long __offset, int __whence) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", __fd, __offset, __whence);
            }
            return (long)mh$.invokeExact(__fd, __offset, __whence);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int close(int __fd)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int close(int __fd)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int close(int __fd)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int close(int __fd)
     * }
     */
    public static int close(int __fd) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class closefrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("closefrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void closefrom(int __lowfd)
     * }
     */
    public static FunctionDescriptor closefrom$descriptor() {
        return closefrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void closefrom(int __lowfd)
     * }
     */
    public static MethodHandle closefrom$handle() {
        return closefrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void closefrom(int __lowfd)
     * }
     */
    public static MemorySegment closefrom$address() {
        return closefrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void closefrom(int __lowfd)
     * }
     */
    public static void closefrom(int __lowfd) {
        var mh$ = closefrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("closefrom", __lowfd);
            }
            mh$.invokeExact(__lowfd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t read(int __fd, void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t read(int __fd, void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t read(int __fd, void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t read(int __fd, void *__buf, size_t __nbytes)
     * }
     */
    public static long read(int __fd, MemorySegment __buf, long __nbytes) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", __fd, __buf, __nbytes);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t write(int __fd, const void *__buf, size_t __n)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t write(int __fd, const void *__buf, size_t __n)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t write(int __fd, const void *__buf, size_t __n)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t write(int __fd, const void *__buf, size_t __n)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __n) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __n);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t pread(int __fd, void *__buf, size_t __nbytes, __off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t pread(int __fd, void *__buf, size_t __nbytes, __off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t pread(int __fd, void *__buf, size_t __nbytes, __off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t pread(int __fd, void *__buf, size_t __nbytes, __off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbytes, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbytes, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbytes, __offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t pwrite(int __fd, const void *__buf, size_t __n, __off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t pwrite(int __fd, const void *__buf, size_t __n, __off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t pwrite(int __fd, const void *__buf, size_t __n, __off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t pwrite(int __fd, const void *__buf, size_t __n, __off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __n, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __n, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pipe(int __pipedes[2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pipe(int __pipedes[2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pipe(int __pipedes[2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pipe(int __pipedes[2])
     * }
     */
    public static int pipe(MemorySegment __pipedes) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", __pipedes);
            }
            return (int)mh$.invokeExact(__pipedes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int alarm(unsigned int __seconds)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int alarm(unsigned int __seconds)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int alarm(unsigned int __seconds)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int alarm(unsigned int __seconds)
     * }
     */
    public static int alarm(int __seconds) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", __seconds);
            }
            return (int)mh$.invokeExact(__seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int sleep(unsigned int __seconds)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int sleep(unsigned int __seconds)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int sleep(unsigned int __seconds)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int sleep(unsigned int __seconds)
     * }
     */
    public static int sleep(int __seconds) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", __seconds);
            }
            return (int)mh$.invokeExact(__seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __useconds_t ualarm(__useconds_t __value, __useconds_t __interval)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __useconds_t ualarm(__useconds_t __value, __useconds_t __interval)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __useconds_t ualarm(__useconds_t __value, __useconds_t __interval)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __useconds_t ualarm(__useconds_t __value, __useconds_t __interval)
     * }
     */
    public static int ualarm(int __value, int __interval) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", __value, __interval);
            }
            return (int)mh$.invokeExact(__value, __interval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int usleep(__useconds_t __useconds)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int usleep(__useconds_t __useconds)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int usleep(__useconds_t __useconds)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int usleep(__useconds_t __useconds)
     * }
     */
    public static int usleep(int __useconds) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", __useconds);
            }
            return (int)mh$.invokeExact(__useconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static int chown(MemorySegment __file, int __owner, int __group) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", __file, __owner, __group);
            }
            return (int)mh$.invokeExact(__file, __owner, __group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchown(int __fd, __uid_t __owner, __gid_t __group)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchown(int __fd, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchown(int __fd, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchown(int __fd, __uid_t __owner, __gid_t __group)
     * }
     */
    public static int fchown(int __fd, int __owner, int __group) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", __fd, __owner, __group);
            }
            return (int)mh$.invokeExact(__fd, __owner, __group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lchown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lchown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lchown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lchown(const char *__file, __uid_t __owner, __gid_t __group)
     * }
     */
    public static int lchown(MemorySegment __file, int __owner, int __group) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", __file, __owner, __group);
            }
            return (int)mh$.invokeExact(__file, __owner, __group);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchownat(int __fd, const char *__file, __uid_t __owner, __gid_t __group, int __flag)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchownat(int __fd, const char *__file, __uid_t __owner, __gid_t __group, int __flag)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchownat(int __fd, const char *__file, __uid_t __owner, __gid_t __group, int __flag)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchownat(int __fd, const char *__file, __uid_t __owner, __gid_t __group, int __flag)
     * }
     */
    public static int fchownat(int __fd, MemorySegment __file, int __owner, int __group, int __flag) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", __fd, __file, __owner, __group, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __owner, __group, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chdir(const char *__path)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chdir(const char *__path)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chdir(const char *__path)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chdir(const char *__path)
     * }
     */
    public static int chdir(MemorySegment __path) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", __path);
            }
            return (int)mh$.invokeExact(__path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchdir(int __fd)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchdir(int __fd)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchdir(int __fd)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchdir(int __fd)
     * }
     */
    public static int fchdir(int __fd) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getcwd(char *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getcwd(char *__buf, size_t __size)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getcwd(char *__buf, size_t __size)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getcwd(char *__buf, size_t __size)
     * }
     */
    public static MemorySegment getcwd(MemorySegment __buf, long __size) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", __buf, __size);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getwd(char *__buf)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getwd(char *__buf)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getwd(char *__buf)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getwd(char *__buf)
     * }
     */
    public static MemorySegment getwd(MemorySegment __buf) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", __buf);
            }
            return (MemorySegment)mh$.invokeExact(__buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dup(int __fd)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dup(int __fd)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dup(int __fd)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dup(int __fd)
     * }
     */
    public static int dup(int __fd) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dup2(int __fd, int __fd2)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dup2(int __fd, int __fd2)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dup2(int __fd, int __fd2)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dup2(int __fd, int __fd2)
     * }
     */
    public static int dup2(int __fd, int __fd2) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", __fd, __fd2);
            }
            return (int)mh$.invokeExact(__fd, __fd2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __environ$constants {
        public static final AddressLayout LAYOUT = uring_syscalls_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__environ").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char **__environ
     * }
     */
    public static AddressLayout __environ$layout() {
        return __environ$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char **__environ
     * }
     */
    public static MemorySegment __environ$segment() {
        return __environ$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char **__environ
     * }
     */
    public static MemorySegment __environ() {
        return __environ$constants.SEGMENT.get(__environ$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char **__environ
     * }
     */
    public static void __environ(MemorySegment varValue) {
        __environ$constants.SEGMENT.set(__environ$constants.LAYOUT, 0L, varValue);
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int execve(const char *__path, char *const __argv[], char *const __envp[])
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int execve(const char *__path, char *const __argv[], char *const __envp[])
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int execve(const char *__path, char *const __argv[], char *const __envp[])
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int execve(const char *__path, char *const __argv[], char *const __envp[])
     * }
     */
    public static int execve(MemorySegment __path, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __path, __argv, __envp);
            }
            return (int)mh$.invokeExact(__path, __argv, __envp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fexecve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fexecve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fexecve(int __fd, char *const __argv[], char *const __envp[])
     * }
     */
    public static FunctionDescriptor fexecve$descriptor() {
        return fexecve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fexecve(int __fd, char *const __argv[], char *const __envp[])
     * }
     */
    public static MethodHandle fexecve$handle() {
        return fexecve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fexecve(int __fd, char *const __argv[], char *const __envp[])
     * }
     */
    public static MemorySegment fexecve$address() {
        return fexecve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fexecve(int __fd, char *const __argv[], char *const __envp[])
     * }
     */
    public static int fexecve(int __fd, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = fexecve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fexecve", __fd, __argv, __envp);
            }
            return (int)mh$.invokeExact(__fd, __argv, __envp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int execv(const char *__path, char *const __argv[])
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int execv(const char *__path, char *const __argv[])
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int execv(const char *__path, char *const __argv[])
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int execv(const char *__path, char *const __argv[])
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int execle(const char *__path, const char *__arg, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_POINTER,
                uring_syscalls_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int execle(const char *__path, const char *__arg, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg, x2);
                }
                return (int) spreader.invokeExact(__path, __arg, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int execl(const char *__path, const char *__arg, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_POINTER,
                uring_syscalls_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int execl(const char *__path, const char *__arg, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg, x2);
                }
                return (int) spreader.invokeExact(__path, __arg, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int execvp(const char *__file, char *const __argv[])
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int execvp(const char *__file, char *const __argv[])
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int execvp(const char *__file, char *const __argv[])
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int execvp(const char *__file, char *const __argv[])
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int execlp(const char *__file, const char *__arg, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_POINTER,
                uring_syscalls_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int execlp(const char *__file, const char *__arg, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg, x2);
                }
                return (int) spreader.invokeExact(__file, __arg, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nice(int __inc)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nice(int __inc)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nice(int __inc)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nice(int __inc)
     * }
     */
    public static int nice(int __inc) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", __inc);
            }
            return (int)mh$.invokeExact(__inc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _exit(int __status)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _exit(int __status)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _exit(int __status)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _exit(int __status)
     * }
     */
    public static void _exit(int __status) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _PC_LINK_MAX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_LINK_MAX = 0
     * }
     */
    public static int _PC_LINK_MAX() {
        return _PC_LINK_MAX;
    }
    private static final int _PC_MAX_CANON = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_MAX_CANON = 1
     * }
     */
    public static int _PC_MAX_CANON() {
        return _PC_MAX_CANON;
    }
    private static final int _PC_MAX_INPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_MAX_INPUT = 2
     * }
     */
    public static int _PC_MAX_INPUT() {
        return _PC_MAX_INPUT;
    }
    private static final int _PC_NAME_MAX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_NAME_MAX = 3
     * }
     */
    public static int _PC_NAME_MAX() {
        return _PC_NAME_MAX;
    }
    private static final int _PC_PATH_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_PATH_MAX = 4
     * }
     */
    public static int _PC_PATH_MAX() {
        return _PC_PATH_MAX;
    }
    private static final int _PC_PIPE_BUF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_PIPE_BUF = 5
     * }
     */
    public static int _PC_PIPE_BUF() {
        return _PC_PIPE_BUF;
    }
    private static final int _PC_CHOWN_RESTRICTED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_CHOWN_RESTRICTED = 6
     * }
     */
    public static int _PC_CHOWN_RESTRICTED() {
        return _PC_CHOWN_RESTRICTED;
    }
    private static final int _PC_NO_TRUNC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_NO_TRUNC = 7
     * }
     */
    public static int _PC_NO_TRUNC() {
        return _PC_NO_TRUNC;
    }
    private static final int _PC_VDISABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_VDISABLE = 8
     * }
     */
    public static int _PC_VDISABLE() {
        return _PC_VDISABLE;
    }
    private static final int _PC_SYNC_IO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_SYNC_IO = 9
     * }
     */
    public static int _PC_SYNC_IO() {
        return _PC_SYNC_IO;
    }
    private static final int _PC_ASYNC_IO = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_ASYNC_IO = 10
     * }
     */
    public static int _PC_ASYNC_IO() {
        return _PC_ASYNC_IO;
    }
    private static final int _PC_PRIO_IO = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_PRIO_IO = 11
     * }
     */
    public static int _PC_PRIO_IO() {
        return _PC_PRIO_IO;
    }
    private static final int _PC_SOCK_MAXBUF = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_SOCK_MAXBUF = 12
     * }
     */
    public static int _PC_SOCK_MAXBUF() {
        return _PC_SOCK_MAXBUF;
    }
    private static final int _PC_FILESIZEBITS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_FILESIZEBITS = 13
     * }
     */
    public static int _PC_FILESIZEBITS() {
        return _PC_FILESIZEBITS;
    }
    private static final int _PC_REC_INCR_XFER_SIZE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_REC_INCR_XFER_SIZE = 14
     * }
     */
    public static int _PC_REC_INCR_XFER_SIZE() {
        return _PC_REC_INCR_XFER_SIZE;
    }
    private static final int _PC_REC_MAX_XFER_SIZE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_REC_MAX_XFER_SIZE = 15
     * }
     */
    public static int _PC_REC_MAX_XFER_SIZE() {
        return _PC_REC_MAX_XFER_SIZE;
    }
    private static final int _PC_REC_MIN_XFER_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_REC_MIN_XFER_SIZE = 16
     * }
     */
    public static int _PC_REC_MIN_XFER_SIZE() {
        return _PC_REC_MIN_XFER_SIZE;
    }
    private static final int _PC_REC_XFER_ALIGN = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_REC_XFER_ALIGN = 17
     * }
     */
    public static int _PC_REC_XFER_ALIGN() {
        return _PC_REC_XFER_ALIGN;
    }
    private static final int _PC_ALLOC_SIZE_MIN = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_ALLOC_SIZE_MIN = 18
     * }
     */
    public static int _PC_ALLOC_SIZE_MIN() {
        return _PC_ALLOC_SIZE_MIN;
    }
    private static final int _PC_SYMLINK_MAX = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_SYMLINK_MAX = 19
     * }
     */
    public static int _PC_SYMLINK_MAX() {
        return _PC_SYMLINK_MAX;
    }
    private static final int _PC_2_SYMLINKS = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PC_2_SYMLINKS = 20
     * }
     */
    public static int _PC_2_SYMLINKS() {
        return _PC_2_SYMLINKS;
    }
    private static final int _SC_ARG_MAX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_ARG_MAX = 0
     * }
     */
    public static int _SC_ARG_MAX() {
        return _SC_ARG_MAX;
    }
    private static final int _SC_CHILD_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CHILD_MAX = 1
     * }
     */
    public static int _SC_CHILD_MAX() {
        return _SC_CHILD_MAX;
    }
    private static final int _SC_CLK_TCK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CLK_TCK = 2
     * }
     */
    public static int _SC_CLK_TCK() {
        return _SC_CLK_TCK;
    }
    private static final int _SC_NGROUPS_MAX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NGROUPS_MAX = 3
     * }
     */
    public static int _SC_NGROUPS_MAX() {
        return _SC_NGROUPS_MAX;
    }
    private static final int _SC_OPEN_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_OPEN_MAX = 4
     * }
     */
    public static int _SC_OPEN_MAX() {
        return _SC_OPEN_MAX;
    }
    private static final int _SC_STREAM_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_STREAM_MAX = 5
     * }
     */
    public static int _SC_STREAM_MAX() {
        return _SC_STREAM_MAX;
    }
    private static final int _SC_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TZNAME_MAX = 6
     * }
     */
    public static int _SC_TZNAME_MAX() {
        return _SC_TZNAME_MAX;
    }
    private static final int _SC_JOB_CONTROL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_JOB_CONTROL = 7
     * }
     */
    public static int _SC_JOB_CONTROL() {
        return _SC_JOB_CONTROL;
    }
    private static final int _SC_SAVED_IDS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SAVED_IDS = 8
     * }
     */
    public static int _SC_SAVED_IDS() {
        return _SC_SAVED_IDS;
    }
    private static final int _SC_REALTIME_SIGNALS = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_REALTIME_SIGNALS = 9
     * }
     */
    public static int _SC_REALTIME_SIGNALS() {
        return _SC_REALTIME_SIGNALS;
    }
    private static final int _SC_PRIORITY_SCHEDULING = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PRIORITY_SCHEDULING = 10
     * }
     */
    public static int _SC_PRIORITY_SCHEDULING() {
        return _SC_PRIORITY_SCHEDULING;
    }
    private static final int _SC_TIMERS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TIMERS = 11
     * }
     */
    public static int _SC_TIMERS() {
        return _SC_TIMERS;
    }
    private static final int _SC_ASYNCHRONOUS_IO = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_ASYNCHRONOUS_IO = 12
     * }
     */
    public static int _SC_ASYNCHRONOUS_IO() {
        return _SC_ASYNCHRONOUS_IO;
    }
    private static final int _SC_PRIORITIZED_IO = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PRIORITIZED_IO = 13
     * }
     */
    public static int _SC_PRIORITIZED_IO() {
        return _SC_PRIORITIZED_IO;
    }
    private static final int _SC_SYNCHRONIZED_IO = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYNCHRONIZED_IO = 14
     * }
     */
    public static int _SC_SYNCHRONIZED_IO() {
        return _SC_SYNCHRONIZED_IO;
    }
    private static final int _SC_FSYNC = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FSYNC = 15
     * }
     */
    public static int _SC_FSYNC() {
        return _SC_FSYNC;
    }
    private static final int _SC_MAPPED_FILES = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MAPPED_FILES = 16
     * }
     */
    public static int _SC_MAPPED_FILES() {
        return _SC_MAPPED_FILES;
    }
    private static final int _SC_MEMLOCK = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MEMLOCK = 17
     * }
     */
    public static int _SC_MEMLOCK() {
        return _SC_MEMLOCK;
    }
    private static final int _SC_MEMLOCK_RANGE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MEMLOCK_RANGE = 18
     * }
     */
    public static int _SC_MEMLOCK_RANGE() {
        return _SC_MEMLOCK_RANGE;
    }
    private static final int _SC_MEMORY_PROTECTION = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MEMORY_PROTECTION = 19
     * }
     */
    public static int _SC_MEMORY_PROTECTION() {
        return _SC_MEMORY_PROTECTION;
    }
    private static final int _SC_MESSAGE_PASSING = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MESSAGE_PASSING = 20
     * }
     */
    public static int _SC_MESSAGE_PASSING() {
        return _SC_MESSAGE_PASSING;
    }
    private static final int _SC_SEMAPHORES = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SEMAPHORES = 21
     * }
     */
    public static int _SC_SEMAPHORES() {
        return _SC_SEMAPHORES;
    }
    private static final int _SC_SHARED_MEMORY_OBJECTS = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SHARED_MEMORY_OBJECTS = 22
     * }
     */
    public static int _SC_SHARED_MEMORY_OBJECTS() {
        return _SC_SHARED_MEMORY_OBJECTS;
    }
    private static final int _SC_AIO_LISTIO_MAX = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_AIO_LISTIO_MAX = 23
     * }
     */
    public static int _SC_AIO_LISTIO_MAX() {
        return _SC_AIO_LISTIO_MAX;
    }
    private static final int _SC_AIO_MAX = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_AIO_MAX = 24
     * }
     */
    public static int _SC_AIO_MAX() {
        return _SC_AIO_MAX;
    }
    private static final int _SC_AIO_PRIO_DELTA_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_AIO_PRIO_DELTA_MAX = 25
     * }
     */
    public static int _SC_AIO_PRIO_DELTA_MAX() {
        return _SC_AIO_PRIO_DELTA_MAX;
    }
    private static final int _SC_DELAYTIMER_MAX = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DELAYTIMER_MAX = 26
     * }
     */
    public static int _SC_DELAYTIMER_MAX() {
        return _SC_DELAYTIMER_MAX;
    }
    private static final int _SC_MQ_OPEN_MAX = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MQ_OPEN_MAX = 27
     * }
     */
    public static int _SC_MQ_OPEN_MAX() {
        return _SC_MQ_OPEN_MAX;
    }
    private static final int _SC_MQ_PRIO_MAX = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MQ_PRIO_MAX = 28
     * }
     */
    public static int _SC_MQ_PRIO_MAX() {
        return _SC_MQ_PRIO_MAX;
    }
    private static final int _SC_VERSION = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_VERSION = 29
     * }
     */
    public static int _SC_VERSION() {
        return _SC_VERSION;
    }
    private static final int _SC_PAGESIZE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PAGESIZE = 30
     * }
     */
    public static int _SC_PAGESIZE() {
        return _SC_PAGESIZE;
    }
    private static final int _SC_RTSIG_MAX = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_RTSIG_MAX = 31
     * }
     */
    public static int _SC_RTSIG_MAX() {
        return _SC_RTSIG_MAX;
    }
    private static final int _SC_SEM_NSEMS_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SEM_NSEMS_MAX = 32
     * }
     */
    public static int _SC_SEM_NSEMS_MAX() {
        return _SC_SEM_NSEMS_MAX;
    }
    private static final int _SC_SEM_VALUE_MAX = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SEM_VALUE_MAX = 33
     * }
     */
    public static int _SC_SEM_VALUE_MAX() {
        return _SC_SEM_VALUE_MAX;
    }
    private static final int _SC_SIGQUEUE_MAX = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SIGQUEUE_MAX = 34
     * }
     */
    public static int _SC_SIGQUEUE_MAX() {
        return _SC_SIGQUEUE_MAX;
    }
    private static final int _SC_TIMER_MAX = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TIMER_MAX = 35
     * }
     */
    public static int _SC_TIMER_MAX() {
        return _SC_TIMER_MAX;
    }
    private static final int _SC_BC_BASE_MAX = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BC_BASE_MAX = 36
     * }
     */
    public static int _SC_BC_BASE_MAX() {
        return _SC_BC_BASE_MAX;
    }
    private static final int _SC_BC_DIM_MAX = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BC_DIM_MAX = 37
     * }
     */
    public static int _SC_BC_DIM_MAX() {
        return _SC_BC_DIM_MAX;
    }
    private static final int _SC_BC_SCALE_MAX = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BC_SCALE_MAX = 38
     * }
     */
    public static int _SC_BC_SCALE_MAX() {
        return _SC_BC_SCALE_MAX;
    }
    private static final int _SC_BC_STRING_MAX = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BC_STRING_MAX = 39
     * }
     */
    public static int _SC_BC_STRING_MAX() {
        return _SC_BC_STRING_MAX;
    }
    private static final int _SC_COLL_WEIGHTS_MAX = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_COLL_WEIGHTS_MAX = 40
     * }
     */
    public static int _SC_COLL_WEIGHTS_MAX() {
        return _SC_COLL_WEIGHTS_MAX;
    }
    private static final int _SC_EQUIV_CLASS_MAX = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_EQUIV_CLASS_MAX = 41
     * }
     */
    public static int _SC_EQUIV_CLASS_MAX() {
        return _SC_EQUIV_CLASS_MAX;
    }
    private static final int _SC_EXPR_NEST_MAX = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_EXPR_NEST_MAX = 42
     * }
     */
    public static int _SC_EXPR_NEST_MAX() {
        return _SC_EXPR_NEST_MAX;
    }
    private static final int _SC_LINE_MAX = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LINE_MAX = 43
     * }
     */
    public static int _SC_LINE_MAX() {
        return _SC_LINE_MAX;
    }
    private static final int _SC_RE_DUP_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_RE_DUP_MAX = 44
     * }
     */
    public static int _SC_RE_DUP_MAX() {
        return _SC_RE_DUP_MAX;
    }
    private static final int _SC_CHARCLASS_NAME_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CHARCLASS_NAME_MAX = 45
     * }
     */
    public static int _SC_CHARCLASS_NAME_MAX() {
        return _SC_CHARCLASS_NAME_MAX;
    }
    private static final int _SC_2_VERSION = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_VERSION = 46
     * }
     */
    public static int _SC_2_VERSION() {
        return _SC_2_VERSION;
    }
    private static final int _SC_2_C_BIND = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_C_BIND = 47
     * }
     */
    public static int _SC_2_C_BIND() {
        return _SC_2_C_BIND;
    }
    private static final int _SC_2_C_DEV = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_C_DEV = 48
     * }
     */
    public static int _SC_2_C_DEV() {
        return _SC_2_C_DEV;
    }
    private static final int _SC_2_FORT_DEV = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_FORT_DEV = 49
     * }
     */
    public static int _SC_2_FORT_DEV() {
        return _SC_2_FORT_DEV;
    }
    private static final int _SC_2_FORT_RUN = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_FORT_RUN = 50
     * }
     */
    public static int _SC_2_FORT_RUN() {
        return _SC_2_FORT_RUN;
    }
    private static final int _SC_2_SW_DEV = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_SW_DEV = 51
     * }
     */
    public static int _SC_2_SW_DEV() {
        return _SC_2_SW_DEV;
    }
    private static final int _SC_2_LOCALEDEF = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_LOCALEDEF = 52
     * }
     */
    public static int _SC_2_LOCALEDEF() {
        return _SC_2_LOCALEDEF;
    }
    private static final int _SC_PII = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII = 53
     * }
     */
    public static int _SC_PII() {
        return _SC_PII;
    }
    private static final int _SC_PII_XTI = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_XTI = 54
     * }
     */
    public static int _SC_PII_XTI() {
        return _SC_PII_XTI;
    }
    private static final int _SC_PII_SOCKET = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_SOCKET = 55
     * }
     */
    public static int _SC_PII_SOCKET() {
        return _SC_PII_SOCKET;
    }
    private static final int _SC_PII_INTERNET = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_INTERNET = 56
     * }
     */
    public static int _SC_PII_INTERNET() {
        return _SC_PII_INTERNET;
    }
    private static final int _SC_PII_OSI = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_OSI = 57
     * }
     */
    public static int _SC_PII_OSI() {
        return _SC_PII_OSI;
    }
    private static final int _SC_POLL = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_POLL = 58
     * }
     */
    public static int _SC_POLL() {
        return _SC_POLL;
    }
    private static final int _SC_SELECT = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SELECT = 59
     * }
     */
    public static int _SC_SELECT() {
        return _SC_SELECT;
    }
    private static final int _SC_UIO_MAXIOV = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_UIO_MAXIOV = 60
     * }
     */
    public static int _SC_UIO_MAXIOV() {
        return _SC_UIO_MAXIOV;
    }
    private static final int _SC_IOV_MAX = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_IOV_MAX = 60
     * }
     */
    public static int _SC_IOV_MAX() {
        return _SC_IOV_MAX;
    }
    private static final int _SC_PII_INTERNET_STREAM = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_INTERNET_STREAM = 61
     * }
     */
    public static int _SC_PII_INTERNET_STREAM() {
        return _SC_PII_INTERNET_STREAM;
    }
    private static final int _SC_PII_INTERNET_DGRAM = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_INTERNET_DGRAM = 62
     * }
     */
    public static int _SC_PII_INTERNET_DGRAM() {
        return _SC_PII_INTERNET_DGRAM;
    }
    private static final int _SC_PII_OSI_COTS = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_OSI_COTS = 63
     * }
     */
    public static int _SC_PII_OSI_COTS() {
        return _SC_PII_OSI_COTS;
    }
    private static final int _SC_PII_OSI_CLTS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_OSI_CLTS = 64
     * }
     */
    public static int _SC_PII_OSI_CLTS() {
        return _SC_PII_OSI_CLTS;
    }
    private static final int _SC_PII_OSI_M = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PII_OSI_M = 65
     * }
     */
    public static int _SC_PII_OSI_M() {
        return _SC_PII_OSI_M;
    }
    private static final int _SC_T_IOV_MAX = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_T_IOV_MAX = 66
     * }
     */
    public static int _SC_T_IOV_MAX() {
        return _SC_T_IOV_MAX;
    }
    private static final int _SC_THREADS = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREADS = 67
     * }
     */
    public static int _SC_THREADS() {
        return _SC_THREADS;
    }
    private static final int _SC_THREAD_SAFE_FUNCTIONS = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_SAFE_FUNCTIONS = 68
     * }
     */
    public static int _SC_THREAD_SAFE_FUNCTIONS() {
        return _SC_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _SC_GETGR_R_SIZE_MAX = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_GETGR_R_SIZE_MAX = 69
     * }
     */
    public static int _SC_GETGR_R_SIZE_MAX() {
        return _SC_GETGR_R_SIZE_MAX;
    }
    private static final int _SC_GETPW_R_SIZE_MAX = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_GETPW_R_SIZE_MAX = 70
     * }
     */
    public static int _SC_GETPW_R_SIZE_MAX() {
        return _SC_GETPW_R_SIZE_MAX;
    }
    private static final int _SC_LOGIN_NAME_MAX = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LOGIN_NAME_MAX = 71
     * }
     */
    public static int _SC_LOGIN_NAME_MAX() {
        return _SC_LOGIN_NAME_MAX;
    }
    private static final int _SC_TTY_NAME_MAX = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TTY_NAME_MAX = 72
     * }
     */
    public static int _SC_TTY_NAME_MAX() {
        return _SC_TTY_NAME_MAX;
    }
    private static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_DESTRUCTOR_ITERATIONS = 73
     * }
     */
    public static int _SC_THREAD_DESTRUCTOR_ITERATIONS() {
        return _SC_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _SC_THREAD_KEYS_MAX = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_KEYS_MAX = 74
     * }
     */
    public static int _SC_THREAD_KEYS_MAX() {
        return _SC_THREAD_KEYS_MAX;
    }
    private static final int _SC_THREAD_STACK_MIN = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_STACK_MIN = 75
     * }
     */
    public static int _SC_THREAD_STACK_MIN() {
        return _SC_THREAD_STACK_MIN;
    }
    private static final int _SC_THREAD_THREADS_MAX = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_THREADS_MAX = 76
     * }
     */
    public static int _SC_THREAD_THREADS_MAX() {
        return _SC_THREAD_THREADS_MAX;
    }
    private static final int _SC_THREAD_ATTR_STACKADDR = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ATTR_STACKADDR = 77
     * }
     */
    public static int _SC_THREAD_ATTR_STACKADDR() {
        return _SC_THREAD_ATTR_STACKADDR;
    }
    private static final int _SC_THREAD_ATTR_STACKSIZE = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ATTR_STACKSIZE = 78
     * }
     */
    public static int _SC_THREAD_ATTR_STACKSIZE() {
        return _SC_THREAD_ATTR_STACKSIZE;
    }
    private static final int _SC_THREAD_PRIORITY_SCHEDULING = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_PRIORITY_SCHEDULING = 79
     * }
     */
    public static int _SC_THREAD_PRIORITY_SCHEDULING() {
        return _SC_THREAD_PRIORITY_SCHEDULING;
    }
    private static final int _SC_THREAD_PRIO_INHERIT = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_PRIO_INHERIT = 80
     * }
     */
    public static int _SC_THREAD_PRIO_INHERIT() {
        return _SC_THREAD_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_PRIO_PROTECT = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_PRIO_PROTECT = 81
     * }
     */
    public static int _SC_THREAD_PRIO_PROTECT() {
        return _SC_THREAD_PRIO_PROTECT;
    }
    private static final int _SC_THREAD_PROCESS_SHARED = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_PROCESS_SHARED = 82
     * }
     */
    public static int _SC_THREAD_PROCESS_SHARED() {
        return _SC_THREAD_PROCESS_SHARED;
    }
    private static final int _SC_NPROCESSORS_CONF = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NPROCESSORS_CONF = 83
     * }
     */
    public static int _SC_NPROCESSORS_CONF() {
        return _SC_NPROCESSORS_CONF;
    }
    private static final int _SC_NPROCESSORS_ONLN = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NPROCESSORS_ONLN = 84
     * }
     */
    public static int _SC_NPROCESSORS_ONLN() {
        return _SC_NPROCESSORS_ONLN;
    }
    private static final int _SC_PHYS_PAGES = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PHYS_PAGES = 85
     * }
     */
    public static int _SC_PHYS_PAGES() {
        return _SC_PHYS_PAGES;
    }
    private static final int _SC_AVPHYS_PAGES = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_AVPHYS_PAGES = 86
     * }
     */
    public static int _SC_AVPHYS_PAGES() {
        return _SC_AVPHYS_PAGES;
    }
    private static final int _SC_ATEXIT_MAX = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_ATEXIT_MAX = 87
     * }
     */
    public static int _SC_ATEXIT_MAX() {
        return _SC_ATEXIT_MAX;
    }
    private static final int _SC_PASS_MAX = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PASS_MAX = 88
     * }
     */
    public static int _SC_PASS_MAX() {
        return _SC_PASS_MAX;
    }
    private static final int _SC_XOPEN_VERSION = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_VERSION = 89
     * }
     */
    public static int _SC_XOPEN_VERSION() {
        return _SC_XOPEN_VERSION;
    }
    private static final int _SC_XOPEN_XCU_VERSION = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_XCU_VERSION = 90
     * }
     */
    public static int _SC_XOPEN_XCU_VERSION() {
        return _SC_XOPEN_XCU_VERSION;
    }
    private static final int _SC_XOPEN_UNIX = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_UNIX = 91
     * }
     */
    public static int _SC_XOPEN_UNIX() {
        return _SC_XOPEN_UNIX;
    }
    private static final int _SC_XOPEN_CRYPT = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_CRYPT = 92
     * }
     */
    public static int _SC_XOPEN_CRYPT() {
        return _SC_XOPEN_CRYPT;
    }
    private static final int _SC_XOPEN_ENH_I18N = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_ENH_I18N = 93
     * }
     */
    public static int _SC_XOPEN_ENH_I18N() {
        return _SC_XOPEN_ENH_I18N;
    }
    private static final int _SC_XOPEN_SHM = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_SHM = 94
     * }
     */
    public static int _SC_XOPEN_SHM() {
        return _SC_XOPEN_SHM;
    }
    private static final int _SC_2_CHAR_TERM = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_CHAR_TERM = 95
     * }
     */
    public static int _SC_2_CHAR_TERM() {
        return _SC_2_CHAR_TERM;
    }
    private static final int _SC_2_C_VERSION = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_C_VERSION = 96
     * }
     */
    public static int _SC_2_C_VERSION() {
        return _SC_2_C_VERSION;
    }
    private static final int _SC_2_UPE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_UPE = 97
     * }
     */
    public static int _SC_2_UPE() {
        return _SC_2_UPE;
    }
    private static final int _SC_XOPEN_XPG2 = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_XPG2 = 98
     * }
     */
    public static int _SC_XOPEN_XPG2() {
        return _SC_XOPEN_XPG2;
    }
    private static final int _SC_XOPEN_XPG3 = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_XPG3 = 99
     * }
     */
    public static int _SC_XOPEN_XPG3() {
        return _SC_XOPEN_XPG3;
    }
    private static final int _SC_XOPEN_XPG4 = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_XPG4 = 100
     * }
     */
    public static int _SC_XOPEN_XPG4() {
        return _SC_XOPEN_XPG4;
    }
    private static final int _SC_CHAR_BIT = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CHAR_BIT = 101
     * }
     */
    public static int _SC_CHAR_BIT() {
        return _SC_CHAR_BIT;
    }
    private static final int _SC_CHAR_MAX = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CHAR_MAX = 102
     * }
     */
    public static int _SC_CHAR_MAX() {
        return _SC_CHAR_MAX;
    }
    private static final int _SC_CHAR_MIN = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CHAR_MIN = 103
     * }
     */
    public static int _SC_CHAR_MIN() {
        return _SC_CHAR_MIN;
    }
    private static final int _SC_INT_MAX = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_INT_MAX = 104
     * }
     */
    public static int _SC_INT_MAX() {
        return _SC_INT_MAX;
    }
    private static final int _SC_INT_MIN = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_INT_MIN = 105
     * }
     */
    public static int _SC_INT_MIN() {
        return _SC_INT_MIN;
    }
    private static final int _SC_LONG_BIT = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LONG_BIT = 106
     * }
     */
    public static int _SC_LONG_BIT() {
        return _SC_LONG_BIT;
    }
    private static final int _SC_WORD_BIT = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_WORD_BIT = 107
     * }
     */
    public static int _SC_WORD_BIT() {
        return _SC_WORD_BIT;
    }
    private static final int _SC_MB_LEN_MAX = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MB_LEN_MAX = 108
     * }
     */
    public static int _SC_MB_LEN_MAX() {
        return _SC_MB_LEN_MAX;
    }
    private static final int _SC_NZERO = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NZERO = 109
     * }
     */
    public static int _SC_NZERO() {
        return _SC_NZERO;
    }
    private static final int _SC_SSIZE_MAX = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SSIZE_MAX = 110
     * }
     */
    public static int _SC_SSIZE_MAX() {
        return _SC_SSIZE_MAX;
    }
    private static final int _SC_SCHAR_MAX = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SCHAR_MAX = 111
     * }
     */
    public static int _SC_SCHAR_MAX() {
        return _SC_SCHAR_MAX;
    }
    private static final int _SC_SCHAR_MIN = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SCHAR_MIN = 112
     * }
     */
    public static int _SC_SCHAR_MIN() {
        return _SC_SCHAR_MIN;
    }
    private static final int _SC_SHRT_MAX = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SHRT_MAX = 113
     * }
     */
    public static int _SC_SHRT_MAX() {
        return _SC_SHRT_MAX;
    }
    private static final int _SC_SHRT_MIN = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SHRT_MIN = 114
     * }
     */
    public static int _SC_SHRT_MIN() {
        return _SC_SHRT_MIN;
    }
    private static final int _SC_UCHAR_MAX = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_UCHAR_MAX = 115
     * }
     */
    public static int _SC_UCHAR_MAX() {
        return _SC_UCHAR_MAX;
    }
    private static final int _SC_UINT_MAX = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_UINT_MAX = 116
     * }
     */
    public static int _SC_UINT_MAX() {
        return _SC_UINT_MAX;
    }
    private static final int _SC_ULONG_MAX = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_ULONG_MAX = 117
     * }
     */
    public static int _SC_ULONG_MAX() {
        return _SC_ULONG_MAX;
    }
    private static final int _SC_USHRT_MAX = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_USHRT_MAX = 118
     * }
     */
    public static int _SC_USHRT_MAX() {
        return _SC_USHRT_MAX;
    }
    private static final int _SC_NL_ARGMAX = (int)119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_ARGMAX = 119
     * }
     */
    public static int _SC_NL_ARGMAX() {
        return _SC_NL_ARGMAX;
    }
    private static final int _SC_NL_LANGMAX = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_LANGMAX = 120
     * }
     */
    public static int _SC_NL_LANGMAX() {
        return _SC_NL_LANGMAX;
    }
    private static final int _SC_NL_MSGMAX = (int)121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_MSGMAX = 121
     * }
     */
    public static int _SC_NL_MSGMAX() {
        return _SC_NL_MSGMAX;
    }
    private static final int _SC_NL_NMAX = (int)122L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_NMAX = 122
     * }
     */
    public static int _SC_NL_NMAX() {
        return _SC_NL_NMAX;
    }
    private static final int _SC_NL_SETMAX = (int)123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_SETMAX = 123
     * }
     */
    public static int _SC_NL_SETMAX() {
        return _SC_NL_SETMAX;
    }
    private static final int _SC_NL_TEXTMAX = (int)124L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NL_TEXTMAX = 124
     * }
     */
    public static int _SC_NL_TEXTMAX() {
        return _SC_NL_TEXTMAX;
    }
    private static final int _SC_XBS5_ILP32_OFF32 = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XBS5_ILP32_OFF32 = 125
     * }
     */
    public static int _SC_XBS5_ILP32_OFF32() {
        return _SC_XBS5_ILP32_OFF32;
    }
    private static final int _SC_XBS5_ILP32_OFFBIG = (int)126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XBS5_ILP32_OFFBIG = 126
     * }
     */
    public static int _SC_XBS5_ILP32_OFFBIG() {
        return _SC_XBS5_ILP32_OFFBIG;
    }
    private static final int _SC_XBS5_LP64_OFF64 = (int)127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XBS5_LP64_OFF64 = 127
     * }
     */
    public static int _SC_XBS5_LP64_OFF64() {
        return _SC_XBS5_LP64_OFF64;
    }
    private static final int _SC_XBS5_LPBIG_OFFBIG = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XBS5_LPBIG_OFFBIG = 128
     * }
     */
    public static int _SC_XBS5_LPBIG_OFFBIG() {
        return _SC_XBS5_LPBIG_OFFBIG;
    }
    private static final int _SC_XOPEN_LEGACY = (int)129L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_LEGACY = 129
     * }
     */
    public static int _SC_XOPEN_LEGACY() {
        return _SC_XOPEN_LEGACY;
    }
    private static final int _SC_XOPEN_REALTIME = (int)130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_REALTIME = 130
     * }
     */
    public static int _SC_XOPEN_REALTIME() {
        return _SC_XOPEN_REALTIME;
    }
    private static final int _SC_XOPEN_REALTIME_THREADS = (int)131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_REALTIME_THREADS = 131
     * }
     */
    public static int _SC_XOPEN_REALTIME_THREADS() {
        return _SC_XOPEN_REALTIME_THREADS;
    }
    private static final int _SC_ADVISORY_INFO = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_ADVISORY_INFO = 132
     * }
     */
    public static int _SC_ADVISORY_INFO() {
        return _SC_ADVISORY_INFO;
    }
    private static final int _SC_BARRIERS = (int)133L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BARRIERS = 133
     * }
     */
    public static int _SC_BARRIERS() {
        return _SC_BARRIERS;
    }
    private static final int _SC_BASE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_BASE = 134
     * }
     */
    public static int _SC_BASE() {
        return _SC_BASE;
    }
    private static final int _SC_C_LANG_SUPPORT = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_C_LANG_SUPPORT = 135
     * }
     */
    public static int _SC_C_LANG_SUPPORT() {
        return _SC_C_LANG_SUPPORT;
    }
    private static final int _SC_C_LANG_SUPPORT_R = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_C_LANG_SUPPORT_R = 136
     * }
     */
    public static int _SC_C_LANG_SUPPORT_R() {
        return _SC_C_LANG_SUPPORT_R;
    }
    private static final int _SC_CLOCK_SELECTION = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CLOCK_SELECTION = 137
     * }
     */
    public static int _SC_CLOCK_SELECTION() {
        return _SC_CLOCK_SELECTION;
    }
    private static final int _SC_CPUTIME = (int)138L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_CPUTIME = 138
     * }
     */
    public static int _SC_CPUTIME() {
        return _SC_CPUTIME;
    }
    private static final int _SC_THREAD_CPUTIME = (int)139L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_CPUTIME = 139
     * }
     */
    public static int _SC_THREAD_CPUTIME() {
        return _SC_THREAD_CPUTIME;
    }
    private static final int _SC_DEVICE_IO = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_IO = 140
     * }
     */
    public static int _SC_DEVICE_IO() {
        return _SC_DEVICE_IO;
    }
    private static final int _SC_DEVICE_SPECIFIC = (int)141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_SPECIFIC = 141
     * }
     */
    public static int _SC_DEVICE_SPECIFIC() {
        return _SC_DEVICE_SPECIFIC;
    }
    private static final int _SC_DEVICE_SPECIFIC_R = (int)142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_DEVICE_SPECIFIC_R = 142
     * }
     */
    public static int _SC_DEVICE_SPECIFIC_R() {
        return _SC_DEVICE_SPECIFIC_R;
    }
    private static final int _SC_FD_MGMT = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FD_MGMT = 143
     * }
     */
    public static int _SC_FD_MGMT() {
        return _SC_FD_MGMT;
    }
    private static final int _SC_FIFO = (int)144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FIFO = 144
     * }
     */
    public static int _SC_FIFO() {
        return _SC_FIFO;
    }
    private static final int _SC_PIPE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_PIPE = 145
     * }
     */
    public static int _SC_PIPE() {
        return _SC_PIPE;
    }
    private static final int _SC_FILE_ATTRIBUTES = (int)146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_ATTRIBUTES = 146
     * }
     */
    public static int _SC_FILE_ATTRIBUTES() {
        return _SC_FILE_ATTRIBUTES;
    }
    private static final int _SC_FILE_LOCKING = (int)147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_LOCKING = 147
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_FILE_SYSTEM = (int)148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_FILE_SYSTEM = 148
     * }
     */
    public static int _SC_FILE_SYSTEM() {
        return _SC_FILE_SYSTEM;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MONOTONIC_CLOCK = 149
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MULTI_PROCESS = (int)150L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MULTI_PROCESS = 150
     * }
     */
    public static int _SC_MULTI_PROCESS() {
        return _SC_MULTI_PROCESS;
    }
    private static final int _SC_SINGLE_PROCESS = (int)151L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SINGLE_PROCESS = 151
     * }
     */
    public static int _SC_SINGLE_PROCESS() {
        return _SC_SINGLE_PROCESS;
    }
    private static final int _SC_NETWORKING = (int)152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_NETWORKING = 152
     * }
     */
    public static int _SC_NETWORKING() {
        return _SC_NETWORKING;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)153L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_READER_WRITER_LOCKS = 153
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_SPIN_LOCKS = (int)154L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPIN_LOCKS = 154
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_REGEXP = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_REGEXP = 155
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_REGEX_VERSION = (int)156L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_REGEX_VERSION = 156
     * }
     */
    public static int _SC_REGEX_VERSION() {
        return _SC_REGEX_VERSION;
    }
    private static final int _SC_SHELL = (int)157L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SHELL = 157
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SIGNALS = (int)158L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SIGNALS = 158
     * }
     */
    public static int _SC_SIGNALS() {
        return _SC_SIGNALS;
    }
    private static final int _SC_SPAWN = (int)159L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPAWN = 159
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPORADIC_SERVER = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SPORADIC_SERVER = 160
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_SPORADIC_SERVER = 161
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_SYSTEM_DATABASE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYSTEM_DATABASE = 162
     * }
     */
    public static int _SC_SYSTEM_DATABASE() {
        return _SC_SYSTEM_DATABASE;
    }
    private static final int _SC_SYSTEM_DATABASE_R = (int)163L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYSTEM_DATABASE_R = 163
     * }
     */
    public static int _SC_SYSTEM_DATABASE_R() {
        return _SC_SYSTEM_DATABASE_R;
    }
    private static final int _SC_TIMEOUTS = (int)164L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TIMEOUTS = 164
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)165L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TYPED_MEMORY_OBJECTS = 165
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_USER_GROUPS = (int)166L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_USER_GROUPS = 166
     * }
     */
    public static int _SC_USER_GROUPS() {
        return _SC_USER_GROUPS;
    }
    private static final int _SC_USER_GROUPS_R = (int)167L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_USER_GROUPS_R = 167
     * }
     */
    public static int _SC_USER_GROUPS_R() {
        return _SC_USER_GROUPS_R;
    }
    private static final int _SC_2_PBS = (int)168L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS = 168
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)169L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_ACCOUNTING = 169
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_LOCATE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_LOCATE = 170
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)171L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_MESSAGE = 171
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)172L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_TRACK = 172
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_SYMLOOP_MAX = (int)173L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SYMLOOP_MAX = 173
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_STREAMS = (int)174L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_STREAMS = 174
     * }
     */
    public static int _SC_STREAMS() {
        return _SC_STREAMS;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)175L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_2_PBS_CHECKPOINT = 175
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)176L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_ILP32_OFF32 = 176
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)177L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_ILP32_OFFBIG = 177
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)178L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_LP64_OFF64 = 178
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)179L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V6_LPBIG_OFFBIG = 179
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_HOST_NAME_MAX = (int)180L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_HOST_NAME_MAX = 180
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_TRACE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE = 181
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)182L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_EVENT_FILTER = 182
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)183L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_INHERIT = 183
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)184L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_LOG = 184
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_LEVEL1_ICACHE_SIZE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_SIZE = 185
     * }
     */
    public static int _SC_LEVEL1_ICACHE_SIZE() {
        return _SC_LEVEL1_ICACHE_SIZE;
    }
    private static final int _SC_LEVEL1_ICACHE_ASSOC = (int)186L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_ASSOC = 186
     * }
     */
    public static int _SC_LEVEL1_ICACHE_ASSOC() {
        return _SC_LEVEL1_ICACHE_ASSOC;
    }
    private static final int _SC_LEVEL1_ICACHE_LINESIZE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_ICACHE_LINESIZE = 187
     * }
     */
    public static int _SC_LEVEL1_ICACHE_LINESIZE() {
        return _SC_LEVEL1_ICACHE_LINESIZE;
    }
    private static final int _SC_LEVEL1_DCACHE_SIZE = (int)188L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_SIZE = 188
     * }
     */
    public static int _SC_LEVEL1_DCACHE_SIZE() {
        return _SC_LEVEL1_DCACHE_SIZE;
    }
    private static final int _SC_LEVEL1_DCACHE_ASSOC = (int)189L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_ASSOC = 189
     * }
     */
    public static int _SC_LEVEL1_DCACHE_ASSOC() {
        return _SC_LEVEL1_DCACHE_ASSOC;
    }
    private static final int _SC_LEVEL1_DCACHE_LINESIZE = (int)190L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL1_DCACHE_LINESIZE = 190
     * }
     */
    public static int _SC_LEVEL1_DCACHE_LINESIZE() {
        return _SC_LEVEL1_DCACHE_LINESIZE;
    }
    private static final int _SC_LEVEL2_CACHE_SIZE = (int)191L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_SIZE = 191
     * }
     */
    public static int _SC_LEVEL2_CACHE_SIZE() {
        return _SC_LEVEL2_CACHE_SIZE;
    }
    private static final int _SC_LEVEL2_CACHE_ASSOC = (int)192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_ASSOC = 192
     * }
     */
    public static int _SC_LEVEL2_CACHE_ASSOC() {
        return _SC_LEVEL2_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL2_CACHE_LINESIZE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL2_CACHE_LINESIZE = 193
     * }
     */
    public static int _SC_LEVEL2_CACHE_LINESIZE() {
        return _SC_LEVEL2_CACHE_LINESIZE;
    }
    private static final int _SC_LEVEL3_CACHE_SIZE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_SIZE = 194
     * }
     */
    public static int _SC_LEVEL3_CACHE_SIZE() {
        return _SC_LEVEL3_CACHE_SIZE;
    }
    private static final int _SC_LEVEL3_CACHE_ASSOC = (int)195L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_ASSOC = 195
     * }
     */
    public static int _SC_LEVEL3_CACHE_ASSOC() {
        return _SC_LEVEL3_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL3_CACHE_LINESIZE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL3_CACHE_LINESIZE = 196
     * }
     */
    public static int _SC_LEVEL3_CACHE_LINESIZE() {
        return _SC_LEVEL3_CACHE_LINESIZE;
    }
    private static final int _SC_LEVEL4_CACHE_SIZE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_SIZE = 197
     * }
     */
    public static int _SC_LEVEL4_CACHE_SIZE() {
        return _SC_LEVEL4_CACHE_SIZE;
    }
    private static final int _SC_LEVEL4_CACHE_ASSOC = (int)198L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_ASSOC = 198
     * }
     */
    public static int _SC_LEVEL4_CACHE_ASSOC() {
        return _SC_LEVEL4_CACHE_ASSOC;
    }
    private static final int _SC_LEVEL4_CACHE_LINESIZE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_LEVEL4_CACHE_LINESIZE = 199
     * }
     */
    public static int _SC_LEVEL4_CACHE_LINESIZE() {
        return _SC_LEVEL4_CACHE_LINESIZE;
    }
    private static final int _SC_IPV6 = (int)235L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_IPV6 = 235
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)236L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_RAW_SOCKETS = 236
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_V7_ILP32_OFF32 = (int)237L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_ILP32_OFF32 = 237
     * }
     */
    public static int _SC_V7_ILP32_OFF32() {
        return _SC_V7_ILP32_OFF32;
    }
    private static final int _SC_V7_ILP32_OFFBIG = (int)238L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_ILP32_OFFBIG = 238
     * }
     */
    public static int _SC_V7_ILP32_OFFBIG() {
        return _SC_V7_ILP32_OFFBIG;
    }
    private static final int _SC_V7_LP64_OFF64 = (int)239L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_LP64_OFF64 = 239
     * }
     */
    public static int _SC_V7_LP64_OFF64() {
        return _SC_V7_LP64_OFF64;
    }
    private static final int _SC_V7_LPBIG_OFFBIG = (int)240L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_V7_LPBIG_OFFBIG = 240
     * }
     */
    public static int _SC_V7_LPBIG_OFFBIG() {
        return _SC_V7_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)241L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SS_REPL_MAX = 241
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)242L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_EVENT_NAME_MAX = 242
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)243L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_NAME_MAX = 243
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)244L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_SYS_MAX = 244
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)245L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_TRACE_USER_EVENT_MAX = 245
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_XOPEN_STREAMS = (int)246L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_XOPEN_STREAMS = 246
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_THREAD_ROBUST_PRIO_INHERIT = (int)247L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ROBUST_PRIO_INHERIT = 247
     * }
     */
    public static int _SC_THREAD_ROBUST_PRIO_INHERIT() {
        return _SC_THREAD_ROBUST_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_ROBUST_PRIO_PROTECT = (int)248L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_THREAD_ROBUST_PRIO_PROTECT = 248
     * }
     */
    public static int _SC_THREAD_ROBUST_PRIO_PROTECT() {
        return _SC_THREAD_ROBUST_PRIO_PROTECT;
    }
    private static final int _SC_MINSIGSTKSZ = (int)249L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_MINSIGSTKSZ = 249
     * }
     */
    public static int _SC_MINSIGSTKSZ() {
        return _SC_MINSIGSTKSZ;
    }
    private static final int _SC_SIGSTKSZ = (int)250L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._SC_SIGSTKSZ = 250
     * }
     */
    public static int _SC_SIGSTKSZ() {
        return _SC_SIGSTKSZ;
    }
    private static final int _CS_PATH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_PATH = 0
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int _CS_V6_WIDTH_RESTRICTED_ENVS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V6_WIDTH_RESTRICTED_ENVS = 1
     * }
     */
    public static int _CS_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_GNU_LIBC_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_GNU_LIBC_VERSION = 2
     * }
     */
    public static int _CS_GNU_LIBC_VERSION() {
        return _CS_GNU_LIBC_VERSION;
    }
    private static final int _CS_GNU_LIBPTHREAD_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_GNU_LIBPTHREAD_VERSION = 3
     * }
     */
    public static int _CS_GNU_LIBPTHREAD_VERSION() {
        return _CS_GNU_LIBPTHREAD_VERSION;
    }
    private static final int _CS_V5_WIDTH_RESTRICTED_ENVS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V5_WIDTH_RESTRICTED_ENVS = 4
     * }
     */
    public static int _CS_V5_WIDTH_RESTRICTED_ENVS() {
        return _CS_V5_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_V7_WIDTH_RESTRICTED_ENVS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V7_WIDTH_RESTRICTED_ENVS = 5
     * }
     */
    public static int _CS_V7_WIDTH_RESTRICTED_ENVS() {
        return _CS_V7_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_LFS_CFLAGS = (int)1000L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_CFLAGS = 1000
     * }
     */
    public static int _CS_LFS_CFLAGS() {
        return _CS_LFS_CFLAGS;
    }
    private static final int _CS_LFS_LDFLAGS = (int)1001L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LDFLAGS = 1001
     * }
     */
    public static int _CS_LFS_LDFLAGS() {
        return _CS_LFS_LDFLAGS;
    }
    private static final int _CS_LFS_LIBS = (int)1002L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LIBS = 1002
     * }
     */
    public static int _CS_LFS_LIBS() {
        return _CS_LFS_LIBS;
    }
    private static final int _CS_LFS_LINTFLAGS = (int)1003L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS_LINTFLAGS = 1003
     * }
     */
    public static int _CS_LFS_LINTFLAGS() {
        return _CS_LFS_LINTFLAGS;
    }
    private static final int _CS_LFS64_CFLAGS = (int)1004L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_CFLAGS = 1004
     * }
     */
    public static int _CS_LFS64_CFLAGS() {
        return _CS_LFS64_CFLAGS;
    }
    private static final int _CS_LFS64_LDFLAGS = (int)1005L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LDFLAGS = 1005
     * }
     */
    public static int _CS_LFS64_LDFLAGS() {
        return _CS_LFS64_LDFLAGS;
    }
    private static final int _CS_LFS64_LIBS = (int)1006L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LIBS = 1006
     * }
     */
    public static int _CS_LFS64_LIBS() {
        return _CS_LFS64_LIBS;
    }
    private static final int _CS_LFS64_LINTFLAGS = (int)1007L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_LFS64_LINTFLAGS = 1007
     * }
     */
    public static int _CS_LFS64_LINTFLAGS() {
        return _CS_LFS64_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)1100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_CFLAGS = 1100
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)1101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LDFLAGS = 1101
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)1102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LIBS = 1102
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)1103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)1104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)1105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)1106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LIBS = 1106
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)1107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)1108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_CFLAGS = 1108
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)1109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LDFLAGS = 1109
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)1110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LIBS = 1110
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)1111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LP64_OFF64_LINTFLAGS = 1111
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)1112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)1113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)1114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LIBS = 1114
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)1115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)1116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)1117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)1118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LIBS = 1118
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = (int)1119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)1120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)1121L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)1122L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = (int)1123L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)1124L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)1125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)1126L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LIBS = 1126
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = (int)1127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LINTFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)1128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)1129L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)1130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = (int)1131L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_CFLAGS = (int)1132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = (int)1133L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LIBS = (int)1134L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LIBS = 1134
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V7_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = (int)1135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS() {
        return _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = (int)1136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = (int)1137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LIBS = (int)1138L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = (int)1139L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
     * }
     */
    public static int _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_CFLAGS = (int)1140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LDFLAGS = (int)1141L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LIBS = (int)1142L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LIBS = 1142
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LIBS() {
        return _CS_POSIX_V7_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = (int)1143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143
     * }
     */
    public static int _CS_POSIX_V7_LP64_OFF64_LINTFLAGS() {
        return _CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = (int)1144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = (int)1145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = (int)1146L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = (int)1147L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147
     * }
     */
    public static int _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_V6_ENV = (int)1148L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V6_ENV = 1148
     * }
     */
    public static int _CS_V6_ENV() {
        return _CS_V6_ENV;
    }
    private static final int _CS_V7_ENV = (int)1149L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CS_V7_ENV = 1149
     * }
     */
    public static int _CS_V7_ENV() {
        return _CS_V7_ENV;
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long pathconf(const char *__path, int __name)
     * }
     */
    public static long pathconf(MemorySegment __path, int __name) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", __path, __name);
            }
            return (long)mh$.invokeExact(__path, __name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long fpathconf(int __fd, int __name)
     * }
     */
    public static long fpathconf(int __fd, int __name) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", __fd, __name);
            }
            return (long)mh$.invokeExact(__fd, __name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long sysconf(int __name)
     * }
     */
    public static long sysconf(int __name) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", __name);
            }
            return (long)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t confstr(int __name, char *__buf, size_t __len)
     * }
     */
    public static long confstr(int __name, MemorySegment __buf, long __len) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", __name, __buf, __len);
            }
            return (long)mh$.invokeExact(__name, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor __getpgid$descriptor() {
        return __getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static MethodHandle __getpgid$handle() {
        return __getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static MemorySegment __getpgid$address() {
        return __getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t __getpgid(__pid_t __pid)
     * }
     */
    public static int __getpgid(int __pid) {
        var mh$ = __getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getpgid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getpgid(__pid_t __pid)
     * }
     */
    public static int getpgid(int __pid) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setpgid(__pid_t __pid, __pid_t __pgid)
     * }
     */
    public static int setpgid(int __pid, int __pgid) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", __pid, __pgid);
            }
            return (int)mh$.invokeExact(__pid, __pgid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t getsid(__pid_t __pid)
     * }
     */
    public static int getsid(int __pid) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getgroups(int __size, __gid_t __list[])
     * }
     */
    public static int getgroups(int __size, MemorySegment __list) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", __size, __list);
            }
            return (int)mh$.invokeExact(__size, __list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setuid(__uid_t __uid)
     * }
     */
    public static int setuid(int __uid) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", __uid);
            }
            return (int)mh$.invokeExact(__uid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setreuid(__uid_t __ruid, __uid_t __euid)
     * }
     */
    public static int setreuid(int __ruid, int __euid) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", __ruid, __euid);
            }
            return (int)mh$.invokeExact(__ruid, __euid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seteuid(__uid_t __uid)
     * }
     */
    public static int seteuid(int __uid) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", __uid);
            }
            return (int)mh$.invokeExact(__uid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setgid(__gid_t __gid)
     * }
     */
    public static int setgid(int __gid) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", __gid);
            }
            return (int)mh$.invokeExact(__gid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setregid(__gid_t __rgid, __gid_t __egid)
     * }
     */
    public static int setregid(int __rgid, int __egid) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", __rgid, __egid);
            }
            return (int)mh$.invokeExact(__rgid, __egid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setegid(__gid_t __gid)
     * }
     */
    public static int setegid(int __gid) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", __gid);
            }
            return (int)mh$.invokeExact(__gid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ttyname(int __fd)
     * }
     */
    public static MemorySegment ttyname(int __fd) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", __fd);
            }
            return (MemorySegment)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ttyname_r(int __fd, char *__buf, size_t __buflen)
     * }
     */
    public static int ttyname_r(int __fd, MemorySegment __buf, long __buflen) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", __fd, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__fd, __buf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isatty(int __fd)
     * }
     */
    public static int isatty(int __fd) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int link(const char *__from, const char *__to)
     * }
     */
    public static int link(MemorySegment __from, MemorySegment __to) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", __from, __to);
            }
            return (int)mh$.invokeExact(__from, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags)
     * }
     */
    public static int linkat(int __fromfd, MemorySegment __from, int __tofd, MemorySegment __to, int __flags) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", __fromfd, __from, __tofd, __to, __flags);
            }
            return (int)mh$.invokeExact(__fromfd, __from, __tofd, __to, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int symlink(const char *__from, const char *__to)
     * }
     */
    public static int symlink(MemorySegment __from, MemorySegment __to) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", __from, __to);
            }
            return (int)mh$.invokeExact(__from, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t readlink(const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static long readlink(MemorySegment __path, MemorySegment __buf, long __len) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", __path, __buf, __len);
            }
            return (long)mh$.invokeExact(__path, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int symlinkat(const char *__from, int __tofd, const char *__to)
     * }
     */
    public static int symlinkat(MemorySegment __from, int __tofd, MemorySegment __to) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", __from, __tofd, __to);
            }
            return (int)mh$.invokeExact(__from, __tofd, __to);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t readlinkat(int __fd, const char *restrict __path, char *restrict __buf, size_t __len)
     * }
     */
    public static long readlinkat(int __fd, MemorySegment __path, MemorySegment __buf, long __len) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", __fd, __path, __buf, __len);
            }
            return (long)mh$.invokeExact(__fd, __path, __buf, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unlink(const char *__name)
     * }
     */
    public static int unlink(MemorySegment __name) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unlinkat(int __fd, const char *__name, int __flag)
     * }
     */
    public static int unlinkat(int __fd, MemorySegment __name, int __flag) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", __fd, __name, __flag);
            }
            return (int)mh$.invokeExact(__fd, __name, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rmdir(const char *__path)
     * }
     */
    public static int rmdir(MemorySegment __path) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", __path);
            }
            return (int)mh$.invokeExact(__path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t tcgetpgrp(int __fd)
     * }
     */
    public static int tcgetpgrp(int __fd) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int tcsetpgrp(int __fd, __pid_t __pgrp_id)
     * }
     */
    public static int tcsetpgrp(int __fd, int __pgrp_id) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", __fd, __pgrp_id);
            }
            return (int)mh$.invokeExact(__fd, __pgrp_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getlogin_r(char *__name, size_t __name_len)
     * }
     */
    public static int getlogin_r(MemorySegment __name, long __name_len) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", __name, __name_len);
            }
            return (int)mh$.invokeExact(__name, __name_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setlogin(const char *__name)
     * }
     */
    public static int setlogin(MemorySegment __name) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = uring_syscalls_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = uring_syscalls_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = uring_syscalls_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = uring_syscalls_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static int getopt(int ___argc, MemorySegment ___argv, MemorySegment __shortopts) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", ___argc, ___argv, __shortopts);
            }
            return (int)mh$.invokeExact(___argc, ___argv, __shortopts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostname(char *__name, size_t __len)
     * }
     */
    public static int gethostname(MemorySegment __name, long __len) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sethostname(const char *__name, size_t __len)
     * }
     */
    public static int sethostname(MemorySegment __name, long __len) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sethostid(long __id)
     * }
     */
    public static int sethostid(long __id) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", __id);
            }
            return (int)mh$.invokeExact(__id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getdomainname(char *__name, size_t __len)
     * }
     */
    public static int getdomainname(MemorySegment __name, long __len) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setdomainname(const char *__name, size_t __len)
     * }
     */
    public static int setdomainname(MemorySegment __name, long __len) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", __name, __len);
            }
            return (int)mh$.invokeExact(__name, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vhangup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vhangup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static FunctionDescriptor vhangup$descriptor() {
        return vhangup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static MethodHandle vhangup$handle() {
        return vhangup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static MemorySegment vhangup$address() {
        return vhangup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vhangup()
     * }
     */
    public static int vhangup() {
        var mh$ = vhangup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vhangup");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int revoke(const char *__file)
     * }
     */
    public static int revoke(MemorySegment __file) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", __file);
            }
            return (int)mh$.invokeExact(__file);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int profil(unsigned short *__sample_buffer, size_t __size, size_t __offset, unsigned int __scale)
     * }
     */
    public static int profil(MemorySegment __sample_buffer, long __size, long __offset, int __scale) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", __sample_buffer, __size, __offset, __scale);
            }
            return (int)mh$.invokeExact(__sample_buffer, __size, __offset, __scale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int acct(const char *__name)
     * }
     */
    public static int acct(MemorySegment __name) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int daemon(int __nochdir, int __noclose)
     * }
     */
    public static int daemon(int __nochdir, int __noclose) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", __nochdir, __noclose);
            }
            return (int)mh$.invokeExact(__nochdir, __noclose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chroot(const char *__path)
     * }
     */
    public static int chroot(MemorySegment __path) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", __path);
            }
            return (int)mh$.invokeExact(__path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getpass(const char *__prompt)
     * }
     */
    public static MemorySegment getpass(MemorySegment __prompt) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", __prompt);
            }
            return (MemorySegment)mh$.invokeExact(__prompt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsync(int __fd)
     * }
     */
    public static int fsync(int __fd) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int truncate(const char *__file, __off_t __length)
     * }
     */
    public static int truncate(MemorySegment __file, long __length) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", __file, __length);
            }
            return (int)mh$.invokeExact(__file, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftruncate(int __fd, __off_t __length)
     * }
     */
    public static int ftruncate(int __fd, long __length) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", __fd, __length);
            }
            return (int)mh$.invokeExact(__fd, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int brk(void *__addr)
     * }
     */
    public static int brk(MemorySegment __addr) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", __addr);
            }
            return (int)mh$.invokeExact(__addr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *sbrk(intptr_t __delta)
     * }
     */
    public static MemorySegment sbrk(long __delta) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", __delta);
            }
            return (MemorySegment)mh$.invokeExact(__delta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern long syscall(long __sysno, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_LONG,
                uring_syscalls_h.C_LONG
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern long syscall(long __sysno, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(long __sysno, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", __sysno, x1);
                }
                return (long) spreader.invokeExact(__sysno, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, __off_t __len)
     * }
     */
    public static int lockf(int __fd, int __cmd, long __len) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", __fd, __cmd, __len);
            }
            return (int)mh$.invokeExact(__fd, __cmd, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdatasync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdatasync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static FunctionDescriptor fdatasync$descriptor() {
        return fdatasync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static MethodHandle fdatasync$handle() {
        return fdatasync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static MemorySegment fdatasync$address() {
        return fdatasync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fdatasync(int __fildes)
     * }
     */
    public static int fdatasync(int __fildes) {
        var mh$ = fdatasync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdatasync", __fildes);
            }
            return (int)mh$.invokeExact(__fildes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *crypt(const char *__key, const char *__salt)
     * }
     */
    public static MemorySegment crypt(MemorySegment __key, MemorySegment __salt) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", __key, __salt);
            }
            return (MemorySegment)mh$.invokeExact(__key, __salt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getentropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getentropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static FunctionDescriptor getentropy$descriptor() {
        return getentropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static MethodHandle getentropy$handle() {
        return getentropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static MemorySegment getentropy$address() {
        return getentropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getentropy(void *__buffer, size_t __length)
     * }
     */
    public static int getentropy(MemorySegment __buffer, long __length) {
        var mh$ = getentropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getentropy", __buffer, __length);
            }
            return (int)mh$.invokeExact(__buffer, __length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfInt nlink_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = uring_syscalls_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = uring_syscalls_h.C_INT;
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_STREAM = 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOCK_DGRAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DGRAM = 2
     * }
     */
    public static int SOCK_DGRAM() {
        return SOCK_DGRAM;
    }
    private static final int SOCK_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RAW = 3
     * }
     */
    public static int SOCK_RAW() {
        return SOCK_RAW;
    }
    private static final int SOCK_RDM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RDM = 4
     * }
     */
    public static int SOCK_RDM() {
        return SOCK_RDM;
    }
    private static final int SOCK_SEQPACKET = (int)5L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_SEQPACKET = 5
     * }
     */
    public static int SOCK_SEQPACKET() {
        return SOCK_SEQPACKET;
    }
    private static final int SOCK_DCCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DCCP = 6
     * }
     */
    public static int SOCK_DCCP() {
        return SOCK_DCCP;
    }
    private static final int SOCK_PACKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_PACKET = 10
     * }
     */
    public static int SOCK_PACKET() {
        return SOCK_PACKET;
    }
    private static final int SOCK_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_CLOEXEC = 524288
     * }
     */
    public static int SOCK_CLOEXEC() {
        return SOCK_CLOEXEC;
    }
    private static final int SOCK_NONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_NONBLOCK = 2048
     * }
     */
    public static int SOCK_NONBLOCK() {
        return SOCK_NONBLOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short sa_family_t
     * }
     */
    public static final OfShort sa_family_t = uring_syscalls_h.C_SHORT;
    private static final int MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_OOB = 1
     * }
     */
    public static int MSG_OOB() {
        return MSG_OOB;
    }
    private static final int MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PEEK = 2
     * }
     */
    public static int MSG_PEEK() {
        return MSG_PEEK;
    }
    private static final int MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTROUTE = 4
     * }
     */
    public static int MSG_DONTROUTE() {
        return MSG_DONTROUTE;
    }
    private static final int MSG_CTRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CTRUNC = 8
     * }
     */
    public static int MSG_CTRUNC() {
        return MSG_CTRUNC;
    }
    private static final int MSG_PROXY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PROXY = 16
     * }
     */
    public static int MSG_PROXY() {
        return MSG_PROXY;
    }
    private static final int MSG_TRUNC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_TRUNC = 32
     * }
     */
    public static int MSG_TRUNC() {
        return MSG_TRUNC;
    }
    private static final int MSG_DONTWAIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTWAIT = 64
     * }
     */
    public static int MSG_DONTWAIT() {
        return MSG_DONTWAIT;
    }
    private static final int MSG_EOR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_EOR = 128
     * }
     */
    public static int MSG_EOR() {
        return MSG_EOR;
    }
    private static final int MSG_WAITALL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITALL = 256
     * }
     */
    public static int MSG_WAITALL() {
        return MSG_WAITALL;
    }
    private static final int MSG_FIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FIN = 512
     * }
     */
    public static int MSG_FIN() {
        return MSG_FIN;
    }
    private static final int MSG_SYN = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SYN = 1024
     * }
     */
    public static int MSG_SYN() {
        return MSG_SYN;
    }
    private static final int MSG_CONFIRM = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CONFIRM = 2048
     * }
     */
    public static int MSG_CONFIRM() {
        return MSG_CONFIRM;
    }
    private static final int MSG_RST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_RST = 4096
     * }
     */
    public static int MSG_RST() {
        return MSG_RST;
    }
    private static final int MSG_ERRQUEUE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ERRQUEUE = 8192
     * }
     */
    public static int MSG_ERRQUEUE() {
        return MSG_ERRQUEUE;
    }
    private static final int MSG_NOSIGNAL = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_NOSIGNAL = 16384
     * }
     */
    public static int MSG_NOSIGNAL() {
        return MSG_NOSIGNAL;
    }
    private static final int MSG_MORE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_MORE = 32768
     * }
     */
    public static int MSG_MORE() {
        return MSG_MORE;
    }
    private static final int MSG_WAITFORONE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITFORONE = 65536
     * }
     */
    public static int MSG_WAITFORONE() {
        return MSG_WAITFORONE;
    }
    private static final int MSG_BATCH = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_BATCH = 262144
     * }
     */
    public static int MSG_BATCH() {
        return MSG_BATCH;
    }
    private static final int MSG_SOCK_DEVMEM = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SOCK_DEVMEM = 33554432
     * }
     */
    public static int MSG_SOCK_DEVMEM() {
        return MSG_SOCK_DEVMEM;
    }
    private static final int MSG_ZEROCOPY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ZEROCOPY = 67108864
     * }
     */
    public static int MSG_ZEROCOPY() {
        return MSG_ZEROCOPY;
    }
    private static final int MSG_FASTOPEN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FASTOPEN = 536870912
     * }
     */
    public static int MSG_FASTOPEN() {
        return MSG_FASTOPEN;
    }
    private static final int MSG_CMSG_CLOEXEC = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CMSG_CLOEXEC = 1073741824
     * }
     */
    public static int MSG_CMSG_CLOEXEC() {
        return MSG_CMSG_CLOEXEC;
    }

    private static class __cmsg_nxthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__cmsg_nxthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static FunctionDescriptor __cmsg_nxthdr$descriptor() {
        return __cmsg_nxthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MethodHandle __cmsg_nxthdr$handle() {
        return __cmsg_nxthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr$address() {
        return __cmsg_nxthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr(MemorySegment __mhdr, MemorySegment __cmsg) {
        var mh$ = __cmsg_nxthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cmsg_nxthdr", __mhdr, __cmsg);
            }
            return (MemorySegment)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCM_RIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCM_RIGHTS = 1
     * }
     */
    public static int SCM_RIGHTS() {
        return SCM_RIGHTS;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_old_dev_t
     * }
     */
    public static final OfInt __kernel_old_dev_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = uring_syscalls_h.C_SHORT;
    private static final int SHUT_RD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RD = 0
     * }
     */
    public static int SHUT_RD() {
        return SHUT_RD;
    }
    private static final int SHUT_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_WR = 1
     * }
     */
    public static int SHUT_WR() {
        return SHUT_WR;
    }
    private static final int SHUT_RDWR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RDWR = 2
     * }
     */
    public static int SHUT_RDWR() {
        return SHUT_RDWR;
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static int socket(int __domain, int __type, int __protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", __domain, __type, __protocol);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static int socketpair(int __domain, int __type, int __protocol, MemorySegment __fds) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", __domain, __type, __protocol, __fds);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int bind(int __fd, MemorySegment __addr, int __len) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getsockname(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int connect(int __fd, MemorySegment __addr, int __len) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getpeername(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static long send(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static long recv(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static long sendto(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, int __addr_len) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static long recvfrom(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static long sendmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static long recvmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static int getsockopt(int __fd, int __level, int __optname, MemorySegment __optval, MemorySegment __optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static int setsockopt(int __fd, int __level, int __optname, MemorySegment __optval, int __optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static int listen(int __fd, int __n) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", __fd, __n);
            }
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static int accept(int __fd, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", __fd, __addr, __addr_len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static int shutdown(int __fd, int __how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", __fd, __how);
            }
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static int sockatmark(int __fd) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isfdtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isfdtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static FunctionDescriptor isfdtype$descriptor() {
        return isfdtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MethodHandle isfdtype$handle() {
        return isfdtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MemorySegment isfdtype$address() {
        return isfdtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static int isfdtype(int __fd, int __fdtype) {
        var mh$ = isfdtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isfdtype", __fd, __fdtype);
            }
            return (int)mh$.invokeExact(__fd, __fdtype);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = uring_syscalls_h.C_INT;
    private static final int IPPROTO_IP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IP = 0
     * }
     */
    public static int IPPROTO_IP() {
        return IPPROTO_IP;
    }
    private static final int IPPROTO_ICMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMP = 1
     * }
     */
    public static int IPPROTO_ICMP() {
        return IPPROTO_ICMP;
    }
    private static final int IPPROTO_IGMP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IGMP = 2
     * }
     */
    public static int IPPROTO_IGMP() {
        return IPPROTO_IGMP;
    }
    private static final int IPPROTO_IPIP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPIP = 4
     * }
     */
    public static int IPPROTO_IPIP() {
        return IPPROTO_IPIP;
    }
    private static final int IPPROTO_TCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TCP = 6
     * }
     */
    public static int IPPROTO_TCP() {
        return IPPROTO_TCP;
    }
    private static final int IPPROTO_EGP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_EGP = 8
     * }
     */
    public static int IPPROTO_EGP() {
        return IPPROTO_EGP;
    }
    private static final int IPPROTO_PUP = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PUP = 12
     * }
     */
    public static int IPPROTO_PUP() {
        return IPPROTO_PUP;
    }
    private static final int IPPROTO_UDP = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDP = 17
     * }
     */
    public static int IPPROTO_UDP() {
        return IPPROTO_UDP;
    }
    private static final int IPPROTO_IDP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IDP = 22
     * }
     */
    public static int IPPROTO_IDP() {
        return IPPROTO_IDP;
    }
    private static final int IPPROTO_TP = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TP = 29
     * }
     */
    public static int IPPROTO_TP() {
        return IPPROTO_TP;
    }
    private static final int IPPROTO_DCCP = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DCCP = 33
     * }
     */
    public static int IPPROTO_DCCP() {
        return IPPROTO_DCCP;
    }
    private static final int IPPROTO_IPV6 = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPV6 = 41
     * }
     */
    public static int IPPROTO_IPV6() {
        return IPPROTO_IPV6;
    }
    private static final int IPPROTO_RSVP = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RSVP = 46
     * }
     */
    public static int IPPROTO_RSVP() {
        return IPPROTO_RSVP;
    }
    private static final int IPPROTO_GRE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_GRE = 47
     * }
     */
    public static int IPPROTO_GRE() {
        return IPPROTO_GRE;
    }
    private static final int IPPROTO_ESP = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ESP = 50
     * }
     */
    public static int IPPROTO_ESP() {
        return IPPROTO_ESP;
    }
    private static final int IPPROTO_AH = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_AH = 51
     * }
     */
    public static int IPPROTO_AH() {
        return IPPROTO_AH;
    }
    private static final int IPPROTO_MTP = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MTP = 92
     * }
     */
    public static int IPPROTO_MTP() {
        return IPPROTO_MTP;
    }
    private static final int IPPROTO_BEETPH = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_BEETPH = 94
     * }
     */
    public static int IPPROTO_BEETPH() {
        return IPPROTO_BEETPH;
    }
    private static final int IPPROTO_ENCAP = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ENCAP = 98
     * }
     */
    public static int IPPROTO_ENCAP() {
        return IPPROTO_ENCAP;
    }
    private static final int IPPROTO_PIM = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PIM = 103
     * }
     */
    public static int IPPROTO_PIM() {
        return IPPROTO_PIM;
    }
    private static final int IPPROTO_COMP = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_COMP = 108
     * }
     */
    public static int IPPROTO_COMP() {
        return IPPROTO_COMP;
    }
    private static final int IPPROTO_L2TP = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_L2TP = 115
     * }
     */
    public static int IPPROTO_L2TP() {
        return IPPROTO_L2TP;
    }
    private static final int IPPROTO_SCTP = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_SCTP = 132
     * }
     */
    public static int IPPROTO_SCTP() {
        return IPPROTO_SCTP;
    }
    private static final int IPPROTO_UDPLITE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDPLITE = 136
     * }
     */
    public static int IPPROTO_UDPLITE() {
        return IPPROTO_UDPLITE;
    }
    private static final int IPPROTO_MPLS = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPLS = 137
     * }
     */
    public static int IPPROTO_MPLS() {
        return IPPROTO_MPLS;
    }
    private static final int IPPROTO_ETHERNET = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ETHERNET = 143
     * }
     */
    public static int IPPROTO_ETHERNET() {
        return IPPROTO_ETHERNET;
    }
    private static final int IPPROTO_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RAW = 255
     * }
     */
    public static int IPPROTO_RAW() {
        return IPPROTO_RAW;
    }
    private static final int IPPROTO_SMC = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_SMC = 256
     * }
     */
    public static int IPPROTO_SMC() {
        return IPPROTO_SMC;
    }
    private static final int IPPROTO_MPTCP = (int)262L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPTCP = 262
     * }
     */
    public static int IPPROTO_MPTCP() {
        return IPPROTO_MPTCP;
    }
    private static final int IPPROTO_MAX = (int)263L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MAX = 263
     * }
     */
    public static int IPPROTO_MAX() {
        return IPPROTO_MAX;
    }
    private static final int IPPROTO_HOPOPTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_HOPOPTS = 0
     * }
     */
    public static int IPPROTO_HOPOPTS() {
        return IPPROTO_HOPOPTS;
    }
    private static final int IPPROTO_ROUTING = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ROUTING = 43
     * }
     */
    public static int IPPROTO_ROUTING() {
        return IPPROTO_ROUTING;
    }
    private static final int IPPROTO_FRAGMENT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_FRAGMENT = 44
     * }
     */
    public static int IPPROTO_FRAGMENT() {
        return IPPROTO_FRAGMENT;
    }
    private static final int IPPROTO_ICMPV6 = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMPV6 = 58
     * }
     */
    public static int IPPROTO_ICMPV6() {
        return IPPROTO_ICMPV6;
    }
    private static final int IPPROTO_NONE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_NONE = 59
     * }
     */
    public static int IPPROTO_NONE() {
        return IPPROTO_NONE;
    }
    private static final int IPPROTO_DSTOPTS = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DSTOPTS = 60
     * }
     */
    public static int IPPROTO_DSTOPTS() {
        return IPPROTO_DSTOPTS;
    }
    private static final int IPPROTO_MH = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MH = 135
     * }
     */
    public static int IPPROTO_MH() {
        return IPPROTO_MH;
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = uring_syscalls_h.C_SHORT;
    private static final int IPPORT_ECHO = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ECHO = 7
     * }
     */
    public static int IPPORT_ECHO() {
        return IPPORT_ECHO;
    }
    private static final int IPPORT_DISCARD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DISCARD = 9
     * }
     */
    public static int IPPORT_DISCARD() {
        return IPPORT_DISCARD;
    }
    private static final int IPPORT_SYSTAT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SYSTAT = 11
     * }
     */
    public static int IPPORT_SYSTAT() {
        return IPPORT_SYSTAT;
    }
    private static final int IPPORT_DAYTIME = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DAYTIME = 13
     * }
     */
    public static int IPPORT_DAYTIME() {
        return IPPORT_DAYTIME;
    }
    private static final int IPPORT_NETSTAT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NETSTAT = 15
     * }
     */
    public static int IPPORT_NETSTAT() {
        return IPPORT_NETSTAT;
    }
    private static final int IPPORT_FTP = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FTP = 21
     * }
     */
    public static int IPPORT_FTP() {
        return IPPORT_FTP;
    }
    private static final int IPPORT_TELNET = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TELNET = 23
     * }
     */
    public static int IPPORT_TELNET() {
        return IPPORT_TELNET;
    }
    private static final int IPPORT_SMTP = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SMTP = 25
     * }
     */
    public static int IPPORT_SMTP() {
        return IPPORT_SMTP;
    }
    private static final int IPPORT_TIMESERVER = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TIMESERVER = 37
     * }
     */
    public static int IPPORT_TIMESERVER() {
        return IPPORT_TIMESERVER;
    }
    private static final int IPPORT_NAMESERVER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NAMESERVER = 42
     * }
     */
    public static int IPPORT_NAMESERVER() {
        return IPPORT_NAMESERVER;
    }
    private static final int IPPORT_WHOIS = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOIS = 43
     * }
     */
    public static int IPPORT_WHOIS() {
        return IPPORT_WHOIS;
    }
    private static final int IPPORT_MTP = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_MTP = 57
     * }
     */
    public static int IPPORT_MTP() {
        return IPPORT_MTP;
    }
    private static final int IPPORT_TFTP = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TFTP = 69
     * }
     */
    public static int IPPORT_TFTP() {
        return IPPORT_TFTP;
    }
    private static final int IPPORT_RJE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_RJE = 77
     * }
     */
    public static int IPPORT_RJE() {
        return IPPORT_RJE;
    }
    private static final int IPPORT_FINGER = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FINGER = 79
     * }
     */
    public static int IPPORT_FINGER() {
        return IPPORT_FINGER;
    }
    private static final int IPPORT_TTYLINK = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TTYLINK = 87
     * }
     */
    public static int IPPORT_TTYLINK() {
        return IPPORT_TTYLINK;
    }
    private static final int IPPORT_SUPDUP = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SUPDUP = 95
     * }
     */
    public static int IPPORT_SUPDUP() {
        return IPPORT_SUPDUP;
    }
    private static final int IPPORT_EXECSERVER = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EXECSERVER = 512
     * }
     */
    public static int IPPORT_EXECSERVER() {
        return IPPORT_EXECSERVER;
    }
    private static final int IPPORT_LOGINSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_LOGINSERVER = 513
     * }
     */
    public static int IPPORT_LOGINSERVER() {
        return IPPORT_LOGINSERVER;
    }
    private static final int IPPORT_CMDSERVER = (int)514L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_CMDSERVER = 514
     * }
     */
    public static int IPPORT_CMDSERVER() {
        return IPPORT_CMDSERVER;
    }
    private static final int IPPORT_EFSSERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EFSSERVER = 520
     * }
     */
    public static int IPPORT_EFSSERVER() {
        return IPPORT_EFSSERVER;
    }
    private static final int IPPORT_BIFFUDP = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_BIFFUDP = 512
     * }
     */
    public static int IPPORT_BIFFUDP() {
        return IPPORT_BIFFUDP;
    }
    private static final int IPPORT_WHOSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOSERVER = 513
     * }
     */
    public static int IPPORT_WHOSERVER() {
        return IPPORT_WHOSERVER;
    }
    private static final int IPPORT_ROUTESERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ROUTESERVER = 520
     * }
     */
    public static int IPPORT_ROUTESERVER() {
        return IPPORT_ROUTESERVER;
    }
    private static final int IPPORT_RESERVED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_RESERVED = 1024
     * }
     */
    public static int IPPORT_RESERVED() {
        return IPPORT_RESERVED;
    }
    private static final int IPPORT_USERRESERVED = (int)5000L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_USERRESERVED = 5000
     * }
     */
    public static int IPPORT_USERRESERVED() {
        return IPPORT_USERRESERVED;
    }

    private static class in6addr_any$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("in6addr_any").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static GroupLayout in6addr_any$layout() {
        return in6addr_any$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static MemorySegment in6addr_any() {
        return in6addr_any$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static void in6addr_any(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_any$constants.SEGMENT, 0L, in6addr_any$constants.LAYOUT.byteSize());
    }

    private static class in6addr_loopback$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("in6addr_loopback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static GroupLayout in6addr_loopback$layout() {
        return in6addr_loopback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static MemorySegment in6addr_loopback() {
        return in6addr_loopback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static void in6addr_loopback(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_loopback$constants.SEGMENT, 0L, in6addr_loopback$constants.LAYOUT.byteSize());
    }

    private static class ntohl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntohl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static FunctionDescriptor ntohl$descriptor() {
        return ntohl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MethodHandle ntohl$handle() {
        return ntohl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MemorySegment ntohl$address() {
        return ntohl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static int ntohl(int __netlong) {
        var mh$ = ntohl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohl", __netlong);
            }
            return (int)mh$.invokeExact(__netlong);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_SHORT,
            uring_syscalls_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ntohs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static FunctionDescriptor ntohs$descriptor() {
        return ntohs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MethodHandle ntohs$handle() {
        return ntohs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MemorySegment ntohs$address() {
        return ntohs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static short ntohs(short __netshort) {
        var mh$ = ntohs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohs", __netshort);
            }
            return (short)mh$.invokeExact(__netshort);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htonl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("htonl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static FunctionDescriptor htonl$descriptor() {
        return htonl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MethodHandle htonl$handle() {
        return htonl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MemorySegment htonl$address() {
        return htonl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static int htonl(int __hostlong) {
        var mh$ = htonl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htonl", __hostlong);
            }
            return (int)mh$.invokeExact(__hostlong);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_SHORT,
            uring_syscalls_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("htons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static FunctionDescriptor htons$descriptor() {
        return htons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MethodHandle htons$handle() {
        return htons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MemorySegment htons$address() {
        return htons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static short htons(short __hostshort) {
        var mh$ = htons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htons", __hostshort);
            }
            return (short)mh$.invokeExact(__hostshort);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bindresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport$descriptor() {
        return bindresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MethodHandle bindresvport$handle() {
        return bindresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MemorySegment bindresvport$address() {
        return bindresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static int bindresvport(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bindresvport6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport6$descriptor() {
        return bindresvport6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MethodHandle bindresvport6$handle() {
        return bindresvport6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MemorySegment bindresvport6$address() {
        return bindresvport6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static int bindresvport6(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport6", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int stat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static int stat(MemorySegment __file, MemorySegment __buf) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", __file, __buf);
            }
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fstat(int __fd, struct stat *__buf)
     * }
     */
    public static int fstat(int __fd, MemorySegment __buf) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", __fd, __buf);
            }
            return (int)mh$.invokeExact(__fd, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fstatat(int __fd, const char *restrict __file, struct stat *restrict __buf, int __flag)
     * }
     */
    public static int fstatat(int __fd, MemorySegment __file, MemorySegment __buf, int __flag) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", __fd, __file, __buf, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __buf, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lstat(const char *restrict __file, struct stat *restrict __buf)
     * }
     */
    public static int lstat(MemorySegment __file, MemorySegment __buf) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", __file, __buf);
            }
            return (int)mh$.invokeExact(__file, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int chmod(const char *__file, __mode_t __mode)
     * }
     */
    public static int chmod(MemorySegment __file, int __mode) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lchmod(const char *__file, __mode_t __mode)
     * }
     */
    public static int lchmod(MemorySegment __file, int __mode) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchmod(int __fd, __mode_t __mode)
     * }
     */
    public static int fchmod(int __fd, int __mode) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", __fd, __mode);
            }
            return (int)mh$.invokeExact(__fd, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fchmodat(int __fd, const char *__file, __mode_t __mode, int __flag)
     * }
     */
    public static int fchmodat(int __fd, MemorySegment __file, int __mode, int __flag) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", __fd, __file, __mode, __flag);
            }
            return (int)mh$.invokeExact(__fd, __file, __mode, __flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __mode_t umask(__mode_t __mask)
     * }
     */
    public static int umask(int __mask) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkdir(const char *__path, __mode_t __mode)
     * }
     */
    public static int mkdir(MemorySegment __path, int __mode) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", __path, __mode);
            }
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkdirat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static int mkdirat(int __fd, MemorySegment __path, int __mode) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", __fd, __path, __mode);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mknod(const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static int mknod(MemorySegment __path, int __mode, long __dev) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", __path, __mode, __dev);
            }
            return (int)mh$.invokeExact(__path, __mode, __dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mknodat(int __fd, const char *__path, __mode_t __mode, __dev_t __dev)
     * }
     */
    public static int mknodat(int __fd, MemorySegment __path, int __mode, long __dev) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", __fd, __path, __mode, __dev);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode, __dev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkfifo(const char *__path, __mode_t __mode)
     * }
     */
    public static int mkfifo(MemorySegment __path, int __mode) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", __path, __mode);
            }
            return (int)mh$.invokeExact(__path, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkfifoat(int __fd, const char *__path, __mode_t __mode)
     * }
     */
    public static int mkfifoat(int __fd, MemorySegment __path, int __mode) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", __fd, __path, __mode);
            }
            return (int)mh$.invokeExact(__fd, __path, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flags)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flags) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flags);
            }
            return (int)mh$.invokeExact(__fd, __path, __times, __flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int)mh$.invokeExact(__fd, __times);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("readv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static FunctionDescriptor readv$descriptor() {
        return readv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static MethodHandle readv$handle() {
        return readv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static MemorySegment readv$address() {
        return readv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t readv(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static long readv(int __fd, MemorySegment __iovec, int __count) {
        var mh$ = readv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readv", __fd, __iovec, __count);
            }
            return (long)mh$.invokeExact(__fd, __iovec, __count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class writev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("writev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static FunctionDescriptor writev$descriptor() {
        return writev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static MethodHandle writev$handle() {
        return writev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static MemorySegment writev$address() {
        return writev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t writev(int __fd, const struct iovec *__iovec, int __count)
     * }
     */
    public static long writev(int __fd, MemorySegment __iovec, int __count) {
        var mh$ = writev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("writev", __fd, __iovec, __count);
            }
            return (long)mh$.invokeExact(__fd, __iovec, __count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class preadv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("preadv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t preadv(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static FunctionDescriptor preadv$descriptor() {
        return preadv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t preadv(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static MethodHandle preadv$handle() {
        return preadv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t preadv(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static MemorySegment preadv$address() {
        return preadv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t preadv(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static long preadv(int __fd, MemorySegment __iovec, int __count, long __offset) {
        var mh$ = preadv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("preadv", __fd, __iovec, __count, __offset);
            }
            return (long)mh$.invokeExact(__fd, __iovec, __count, __offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwritev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pwritev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t pwritev(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static FunctionDescriptor pwritev$descriptor() {
        return pwritev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t pwritev(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static MethodHandle pwritev$handle() {
        return pwritev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t pwritev(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static MemorySegment pwritev$address() {
        return pwritev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t pwritev(int __fd, const struct iovec *__iovec, int __count, __off_t __offset)
     * }
     */
    public static long pwritev(int __fd, MemorySegment __iovec, int __count, long __offset) {
        var mh$ = pwritev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwritev", __fd, __iovec, __count, __offset);
            }
            return (long)mh$.invokeExact(__fd, __iovec, __count, __offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static FunctionDescriptor __errno_location$descriptor() {
        return __errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MethodHandle __errno_location$handle() {
        return __errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location$address() {
        return __errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location() {
        var mh$ = __errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __sig_atomic_t sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = uring_syscalls_h.C_INT;
    private static final int SI_ASYNCNL = (int)-60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_ASYNCNL = -60
     * }
     */
    public static int SI_ASYNCNL() {
        return SI_ASYNCNL;
    }
    private static final int SI_DETHREAD = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_DETHREAD = -7
     * }
     */
    public static int SI_DETHREAD() {
        return SI_DETHREAD;
    }
    private static final int SI_TKILL = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_TKILL = -6
     * }
     */
    public static int SI_TKILL() {
        return SI_TKILL;
    }
    private static final int SI_SIGIO = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_SIGIO = -5
     * }
     */
    public static int SI_SIGIO() {
        return SI_SIGIO;
    }
    private static final int SI_ASYNCIO = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_ASYNCIO = -4
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_MESGQ = -3
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SI_TIMER = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_TIMER = -2
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_QUEUE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_QUEUE = -1
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_USER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_USER = 0
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_KERNEL = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SI_KERNEL = 128
     * }
     */
    public static int SI_KERNEL() {
        return SI_KERNEL;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLOPC = 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLOPN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLOPN = 2
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLADR = 3
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_ILLTRP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_ILLTRP = 4
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_PRVOPC = 5
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_PRVREG = 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_COPROC = 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_BADSTK = 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int ILL_BADIADDR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ILL_BADIADDR = 9
     * }
     */
    public static int ILL_BADIADDR() {
        return ILL_BADIADDR;
    }
    private static final int FPE_INTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_INTDIV = 1
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_INTOVF = 2
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int FPE_FLTDIV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTDIV = 3
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTOVF = 4
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUND = 5
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTRES = 6
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTINV = 7
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTSUB = 8
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_FLTUNK = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUNK = 14
     * }
     */
    public static int FPE_FLTUNK() {
        return FPE_FLTUNK;
    }
    private static final int FPE_CONDTRAP = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_CONDTRAP = 15
     * }
     */
    public static int FPE_CONDTRAP() {
        return FPE_CONDTRAP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MAPERR = 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCERR = 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int SEGV_BNDERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_BNDERR = 3
     * }
     */
    public static int SEGV_BNDERR() {
        return SEGV_BNDERR;
    }
    private static final int SEGV_PKUERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_PKUERR = 4
     * }
     */
    public static int SEGV_PKUERR() {
        return SEGV_PKUERR;
    }
    private static final int SEGV_ACCADI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCADI = 5
     * }
     */
    public static int SEGV_ACCADI() {
        return SEGV_ACCADI;
    }
    private static final int SEGV_ADIDERR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIDERR = 6
     * }
     */
    public static int SEGV_ADIDERR() {
        return SEGV_ADIDERR;
    }
    private static final int SEGV_ADIPERR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIPERR = 7
     * }
     */
    public static int SEGV_ADIPERR() {
        return SEGV_ADIPERR;
    }
    private static final int SEGV_MTEAERR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTEAERR = 8
     * }
     */
    public static int SEGV_MTEAERR() {
        return SEGV_MTEAERR;
    }
    private static final int SEGV_MTESERR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTESERR = 9
     * }
     */
    public static int SEGV_MTESERR() {
        return SEGV_MTESERR;
    }
    private static final int SEGV_CPERR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_CPERR = 10
     * }
     */
    public static int SEGV_CPERR() {
        return SEGV_CPERR;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRALN = 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRERR = 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_OBJERR = 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int BUS_MCEERR_AR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AR = 4
     * }
     */
    public static int BUS_MCEERR_AR() {
        return BUS_MCEERR_AR;
    }
    private static final int BUS_MCEERR_AO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AO = 5
     * }
     */
    public static int BUS_MCEERR_AO() {
        return BUS_MCEERR_AO;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_EXITED = 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_KILLED = 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_DUMPED = 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_TRAPPED = 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_STOPPED = 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_CONTINUED = 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_IN = 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_OUT = 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_MSG = 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_ERR = 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_PRI = 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_HUP = 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SIGEV_SIGNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_SIGNAL = 0
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_NONE = 1
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_THREAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD = 2
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int SIGEV_THREAD_ID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD_ID = 4
     * }
     */
    public static int SIGEV_THREAD_ID() {
        return SIGEV_THREAD_ID;
    }

    private static class __sysv_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sysv_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor __sysv_signal$descriptor() {
        return __sysv_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle __sysv_signal$handle() {
        return __sysv_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal$address() {
        return __sysv_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal(int __sig, MemorySegment __handler) {
        var mh$ = __sysv_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sysv_signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal(int __sig, MemorySegment __handler) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static FunctionDescriptor kill$descriptor() {
        return kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MethodHandle kill$handle() {
        return kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MemorySegment kill$address() {
        return kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static int kill(int __pid, int __sig) {
        var mh$ = kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kill", __pid, __sig);
            }
            return (int)mh$.invokeExact(__pid, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class killpg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("killpg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static FunctionDescriptor killpg$descriptor() {
        return killpg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MethodHandle killpg$handle() {
        return killpg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MemorySegment killpg$address() {
        return killpg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static int killpg(int __pgrp, int __sig) {
        var mh$ = killpg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("killpg", __pgrp, __sig);
            }
            return (int)mh$.invokeExact(__pgrp, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class raise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("raise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static FunctionDescriptor raise$descriptor() {
        return raise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MethodHandle raise$handle() {
        return raise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MemorySegment raise$address() {
        return raise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static int raise(int __sig) {
        var mh$ = raise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("raise", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ssignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor ssignal$descriptor() {
        return ssignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle ssignal$handle() {
        return ssignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal$address() {
        return ssignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal(int __sig, MemorySegment __handler) {
        var mh$ = ssignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssignal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static FunctionDescriptor gsignal$descriptor() {
        return gsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MethodHandle gsignal$handle() {
        return gsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MemorySegment gsignal$address() {
        return gsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static int gsignal(int __sig) {
        var mh$ = gsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gsignal", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static FunctionDescriptor psignal$descriptor() {
        return psignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MethodHandle psignal$handle() {
        return psignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MemorySegment psignal$address() {
        return psignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static void psignal(int __sig, MemorySegment __s) {
        var mh$ = psignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psignal", __sig, __s);
            }
            mh$.invokeExact(__sig, __s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psiginfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psiginfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static FunctionDescriptor psiginfo$descriptor() {
        return psiginfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MethodHandle psiginfo$handle() {
        return psiginfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MemorySegment psiginfo$address() {
        return psiginfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static void psiginfo(MemorySegment __pinfo, MemorySegment __s) {
        var mh$ = psiginfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psiginfo", __pinfo, __s);
            }
            mh$.invokeExact(__pinfo, __s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigblock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigblock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static FunctionDescriptor sigblock$descriptor() {
        return sigblock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MethodHandle sigblock$handle() {
        return sigblock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MemorySegment sigblock$address() {
        return sigblock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static int sigblock(int __mask) {
        var mh$ = sigblock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigblock", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigsetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static FunctionDescriptor sigsetmask$descriptor() {
        return sigsetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MethodHandle sigsetmask$handle() {
        return sigsetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MemorySegment sigsetmask$address() {
        return sigsetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static int sigsetmask(int __mask) {
        var mh$ = sigsetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsetmask", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class siggetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("siggetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static FunctionDescriptor siggetmask$descriptor() {
        return siggetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MethodHandle siggetmask$handle() {
        return siggetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MemorySegment siggetmask$address() {
        return siggetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static int siggetmask() {
        var mh$ = siggetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siggetmask");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigemptyset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigemptyset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigemptyset$descriptor() {
        return sigemptyset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigemptyset$handle() {
        return sigemptyset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigemptyset$address() {
        return sigemptyset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static int sigemptyset(MemorySegment __set) {
        var mh$ = sigemptyset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigemptyset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigfillset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigfillset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigfillset$descriptor() {
        return sigfillset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigfillset$handle() {
        return sigfillset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigfillset$address() {
        return sigfillset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static int sigfillset(MemorySegment __set) {
        var mh$ = sigfillset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigfillset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaddset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaddset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigaddset$descriptor() {
        return sigaddset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigaddset$handle() {
        return sigaddset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigaddset$address() {
        return sigaddset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigaddset(MemorySegment __set, int __signo) {
        var mh$ = sigaddset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaddset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigdelset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigdelset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigdelset$descriptor() {
        return sigdelset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigdelset$handle() {
        return sigdelset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigdelset$address() {
        return sigdelset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigdelset(MemorySegment __set, int __signo) {
        var mh$ = sigdelset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigdelset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigismember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigismember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigismember$descriptor() {
        return sigismember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigismember$handle() {
        return sigismember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigismember$address() {
        return sigismember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static int sigismember(MemorySegment __set, int __signo) {
        var mh$ = sigismember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigismember", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigprocmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigprocmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static FunctionDescriptor sigprocmask$descriptor() {
        return sigprocmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MethodHandle sigprocmask$handle() {
        return sigprocmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MemorySegment sigprocmask$address() {
        return sigprocmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static int sigprocmask(int __how, MemorySegment __set, MemorySegment __oset) {
        var mh$ = sigprocmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigprocmask", __how, __set, __oset);
            }
            return (int)mh$.invokeExact(__how, __set, __oset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsuspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigsuspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigsuspend$descriptor() {
        return sigsuspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MethodHandle sigsuspend$handle() {
        return sigsuspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MemorySegment sigsuspend$address() {
        return sigsuspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static int sigsuspend(MemorySegment __set) {
        var mh$ = sigsuspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsuspend", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static FunctionDescriptor sigaction$descriptor() {
        return sigaction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MethodHandle sigaction$handle() {
        return sigaction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MemorySegment sigaction$address() {
        return sigaction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static int sigaction(int __sig, MemorySegment __act, MemorySegment __oact) {
        var mh$ = sigaction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaction", __sig, __act, __oact);
            }
            return (int)mh$.invokeExact(__sig, __act, __oact);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigpending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigpending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigpending$descriptor() {
        return sigpending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MethodHandle sigpending$handle() {
        return sigpending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MemorySegment sigpending$address() {
        return sigpending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static int sigpending(MemorySegment __set) {
        var mh$ = sigpending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigpending", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static FunctionDescriptor sigwait$descriptor() {
        return sigwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MethodHandle sigwait$handle() {
        return sigwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MemorySegment sigwait$address() {
        return sigwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static int sigwait(MemorySegment __set, MemorySegment __sig) {
        var mh$ = sigwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwait", __set, __sig);
            }
            return (int)mh$.invokeExact(__set, __sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwaitinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigwaitinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static FunctionDescriptor sigwaitinfo$descriptor() {
        return sigwaitinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MethodHandle sigwaitinfo$handle() {
        return sigwaitinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MemorySegment sigwaitinfo$address() {
        return sigwaitinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static int sigwaitinfo(MemorySegment __set, MemorySegment __info) {
        var mh$ = sigwaitinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwaitinfo", __set, __info);
            }
            return (int)mh$.invokeExact(__set, __info);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigtimedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigtimedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static FunctionDescriptor sigtimedwait$descriptor() {
        return sigtimedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MethodHandle sigtimedwait$handle() {
        return sigtimedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MemorySegment sigtimedwait$address() {
        return sigtimedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static int sigtimedwait(MemorySegment __set, MemorySegment __info, MemorySegment __timeout) {
        var mh$ = sigtimedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigtimedwait", __set, __info, __timeout);
            }
            return (int)mh$.invokeExact(__set, __info, __timeout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            sigval.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static FunctionDescriptor sigqueue$descriptor() {
        return sigqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MethodHandle sigqueue$handle() {
        return sigqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MemorySegment sigqueue$address() {
        return sigqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static int sigqueue(int __pid, int __sig, MemorySegment __val) {
        var mh$ = sigqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigqueue", __pid, __sig, __val);
            }
            return (int)mh$.invokeExact(__pid, __sig, __val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __s8
     * }
     */
    public static final OfByte __s8 = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u8
     * }
     */
    public static final OfByte __u8 = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __s16
     * }
     */
    public static final OfShort __s16 = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u16
     * }
     */
    public static final OfShort __u16 = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __s32
     * }
     */
    public static final OfInt __s32 = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u32
     * }
     */
    public static final OfInt __u32 = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __s64
     * }
     */
    public static final OfLong __s64 = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __u64
     * }
     */
    public static final OfLong __u64 = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u16 __le16
     * }
     */
    public static final OfShort __le16 = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u16 __be16
     * }
     */
    public static final OfShort __be16 = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __le32
     * }
     */
    public static final OfInt __le32 = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __be32
     * }
     */
    public static final OfInt __be32 = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u64 __le64
     * }
     */
    public static final OfLong __le64 = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u64 __be64
     * }
     */
    public static final OfLong __be64 = uring_syscalls_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u16 __sum16
     * }
     */
    public static final OfShort __sum16 = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __wsum
     * }
     */
    public static final OfInt __wsum = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __poll_t
     * }
     */
    public static final OfInt __poll_t = uring_syscalls_h.C_INT;

    private static class sigreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static FunctionDescriptor sigreturn$descriptor() {
        return sigreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MethodHandle sigreturn$handle() {
        return sigreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MemorySegment sigreturn$address() {
        return sigreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static int sigreturn(MemorySegment __scp) {
        var mh$ = sigreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigreturn", __scp);
            }
            return (int)mh$.invokeExact(__scp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static int gettimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static int settimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static int adjtime(MemorySegment __delta, MemorySegment __olddelta) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", __delta, __olddelta);
            }
            return (int)mh$.invokeExact(__delta, __olddelta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ITIMER_REAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_REAL = 0
     * }
     */
    public static int ITIMER_REAL() {
        return ITIMER_REAL;
    }
    private static final int ITIMER_VIRTUAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_VIRTUAL = 1
     * }
     */
    public static int ITIMER_VIRTUAL() {
        return ITIMER_VIRTUAL;
    }
    private static final int ITIMER_PROF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_PROF = 2
     * }
     */
    public static int ITIMER_PROF() {
        return ITIMER_PROF;
    }
    /**
     * {@snippet lang=c :
     * typedef int __itimer_which_t
     * }
     */
    public static final OfInt __itimer_which_t = uring_syscalls_h.C_INT;

    private static class getitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static int getitimer(int __which, MemorySegment __value) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", __which, __value);
            }
            return (int)mh$.invokeExact(__which, __value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static int setitimer(int __which, MemorySegment __new, MemorySegment __old) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", __which, __new, __old);
            }
            return (int)mh$.invokeExact(__which, __new, __old);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int utimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int lutimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static int futimes(int __fd, MemorySegment __tvp) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", __fd, __tvp);
            }
            return (int)mh$.invokeExact(__fd, __tvp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t elf_greg_t
     * }
     */
    public static final OfLong elf_greg_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __pr_uid_t
     * }
     */
    public static final OfInt __pr_uid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __pr_gid_t
     * }
     */
    public static final OfInt __pr_gid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *psaddr_t
     * }
     */
    public static final AddressLayout psaddr_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __pid_t lwpid_t
     * }
     */
    public static final OfInt lwpid_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef elf_greg_t greg_t
     * }
     */
    public static final OfLong greg_t = uring_syscalls_h.C_LONG;

    private static class siginterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("siginterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static FunctionDescriptor siginterrupt$descriptor() {
        return siginterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MethodHandle siginterrupt$handle() {
        return siginterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MemorySegment siginterrupt$address() {
        return siginterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static int siginterrupt(int __sig, int __interrupt) {
        var mh$ = siginterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siginterrupt", __sig, __interrupt);
            }
            return (int)mh$.invokeExact(__sig, __interrupt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_ONSTACK = 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_DISABLE = 2
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }

    private static class sigaltstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigaltstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static FunctionDescriptor sigaltstack$descriptor() {
        return sigaltstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MethodHandle sigaltstack$handle() {
        return sigaltstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MemorySegment sigaltstack$address() {
        return sigaltstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static int sigaltstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigaltstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaltstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sigstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static FunctionDescriptor sigstack$descriptor() {
        return sigstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MethodHandle sigstack$handle() {
        return sigstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MemorySegment sigstack$address() {
        return sigstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static int sigstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_sigmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pthread_sigmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static FunctionDescriptor pthread_sigmask$descriptor() {
        return pthread_sigmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MethodHandle pthread_sigmask$handle() {
        return pthread_sigmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MemorySegment pthread_sigmask$address() {
        return pthread_sigmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static int pthread_sigmask(int __how, MemorySegment __newmask, MemorySegment __oldmask) {
        var mh$ = pthread_sigmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_sigmask", __how, __newmask, __oldmask);
            }
            return (int)mh$.invokeExact(__how, __newmask, __oldmask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pthread_kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static FunctionDescriptor pthread_kill$descriptor() {
        return pthread_kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MethodHandle pthread_kill$handle() {
        return pthread_kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MemorySegment pthread_kill$address() {
        return pthread_kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static int pthread_kill(long __threadid, int __signo) {
        var mh$ = pthread_kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_kill", __threadid, __signo);
            }
            return (int)mh$.invokeExact(__threadid, __signo);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__libc_current_sigrtmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmin$descriptor() {
        return __libc_current_sigrtmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MethodHandle __libc_current_sigrtmin$handle() {
        return __libc_current_sigrtmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MemorySegment __libc_current_sigrtmin$address() {
        return __libc_current_sigrtmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static int __libc_current_sigrtmin() {
        var mh$ = __libc_current_sigrtmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmin");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__libc_current_sigrtmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmax$descriptor() {
        return __libc_current_sigrtmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MethodHandle __libc_current_sigrtmax$handle() {
        return __libc_current_sigrtmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MemorySegment __libc_current_sigrtmax$address() {
        return __libc_current_sigrtmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static int __libc_current_sigrtmax() {
        var mh$ = __libc_current_sigrtmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmax");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = uring_syscalls_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = uring_syscalls_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = uring_syscalls_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = uring_syscalls_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = uring_syscalls_h.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = uring_syscalls_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = uring_syscalls_h.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_DOUBLE,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, uring_syscalls_h.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = uring_syscalls_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = uring_syscalls_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, uring_syscalls_h.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = uring_syscalls_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = uring_syscalls_h.C_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fcntl(int __fd, int __cmd, ...)
     * }
     */
    public static class fcntl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcntl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fcntl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fcntl(int __fd, int __cmd, ...)
         * }
         */
        public static fcntl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fcntl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, int __cmd, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fcntl", __fd, __cmd, x2);
                }
                return (int) spreader.invokeExact(__fd, __cmd, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int open(const char *__file, int __oflag, ...)
     * }
     */
    public static class open {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_POINTER,
                uring_syscalls_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("open");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private open(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int open(const char *__file, int __oflag, ...)
         * }
         */
        public static open makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new open(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, int __oflag, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("open", __file, __oflag, x2);
                }
                return (int) spreader.invokeExact(__file, __oflag, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int openat(int __fd, const char *__file, int __oflag, ...)
     * }
     */
    public static class openat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_INT,
                uring_syscalls_h.C_POINTER,
                uring_syscalls_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("openat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private openat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int openat(int __fd, const char *__file, int __oflag, ...)
         * }
         */
        public static openat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new openat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __file, int __oflag, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("openat", __fd, __file, __oflag, x3);
                }
                return (int) spreader.invokeExact(__fd, __file, __oflag, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class creat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("creat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static FunctionDescriptor creat$descriptor() {
        return creat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static MethodHandle creat$handle() {
        return creat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static MemorySegment creat$address() {
        return creat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static int creat(MemorySegment __file, int __mode) {
        var mh$ = creat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creat", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_fadvise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_fadvise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static FunctionDescriptor posix_fadvise$descriptor() {
        return posix_fadvise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static MethodHandle posix_fadvise$handle() {
        return posix_fadvise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static MemorySegment posix_fadvise$address() {
        return posix_fadvise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static int posix_fadvise(int __fd, long __offset, long __len, int __advise) {
        var mh$ = posix_fadvise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_fadvise", __fd, __offset, __len, __advise);
            }
            return (int)mh$.invokeExact(__fd, __offset, __len, __advise);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_fallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_fallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static FunctionDescriptor posix_fallocate$descriptor() {
        return posix_fallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static MethodHandle posix_fallocate$handle() {
        return posix_fallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static MemorySegment posix_fallocate$address() {
        return posix_fallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static int posix_fallocate(int __fd, long __offset, long __len) {
        var mh$ = posix_fallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_fallocate", __fd, __offset, __len);
            }
            return (int)mh$.invokeExact(__fd, __offset, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = uring_syscalls_h.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_LONG,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    private static final int P_PIDFD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PIDFD = 3
     * }
     */
    public static int P_PIDFD() {
        return P_PIDFD;
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static int wait(MemorySegment __stat_loc) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", __stat_loc);
            }
            return (int)mh$.invokeExact(__stat_loc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static int waitpid(int __pid, MemorySegment __stat_loc, int __options) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", __pid, __stat_loc, __options);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static int waitid(int __idtype, int __id, MemorySegment __infop, int __options) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", __idtype, __id, __infop, __options);
            }
            return (int)mh$.invokeExact(__idtype, __id, __infop, __options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait3(MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__stat_loc, __options, __usage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER,
            uring_syscalls_h.C_INT,
            uring_syscalls_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait4(int __pid, MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", __pid, __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options, __usage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FSCONFIG_SET_FLAG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_FLAG = 0
     * }
     */
    public static int FSCONFIG_SET_FLAG() {
        return FSCONFIG_SET_FLAG;
    }
    private static final int FSCONFIG_SET_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_STRING = 1
     * }
     */
    public static int FSCONFIG_SET_STRING() {
        return FSCONFIG_SET_STRING;
    }
    private static final int FSCONFIG_SET_BINARY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_BINARY = 2
     * }
     */
    public static int FSCONFIG_SET_BINARY() {
        return FSCONFIG_SET_BINARY;
    }
    private static final int FSCONFIG_SET_PATH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_PATH = 3
     * }
     */
    public static int FSCONFIG_SET_PATH() {
        return FSCONFIG_SET_PATH;
    }
    private static final int FSCONFIG_SET_PATH_EMPTY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_PATH_EMPTY = 4
     * }
     */
    public static int FSCONFIG_SET_PATH_EMPTY() {
        return FSCONFIG_SET_PATH_EMPTY;
    }
    private static final int FSCONFIG_SET_FD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_FD = 5
     * }
     */
    public static int FSCONFIG_SET_FD() {
        return FSCONFIG_SET_FD;
    }
    private static final int FSCONFIG_CMD_CREATE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_CREATE = 6
     * }
     */
    public static int FSCONFIG_CMD_CREATE() {
        return FSCONFIG_CMD_CREATE;
    }
    private static final int FSCONFIG_CMD_RECONFIGURE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_RECONFIGURE = 7
     * }
     */
    public static int FSCONFIG_CMD_RECONFIGURE() {
        return FSCONFIG_CMD_RECONFIGURE;
    }
    private static final int FSCONFIG_CMD_CREATE_EXCL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_CREATE_EXCL = 8
     * }
     */
    public static int FSCONFIG_CMD_CREATE_EXCL() {
        return FSCONFIG_CMD_CREATE_EXCL;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_rwf_t
     * }
     */
    public static final OfInt __kernel_rwf_t = uring_syscalls_h.C_INT;
    private static final int PROCMAP_QUERY_VMA_READABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_VMA_READABLE = 1
     * }
     */
    public static int PROCMAP_QUERY_VMA_READABLE() {
        return PROCMAP_QUERY_VMA_READABLE;
    }
    private static final int PROCMAP_QUERY_VMA_WRITABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_VMA_WRITABLE = 2
     * }
     */
    public static int PROCMAP_QUERY_VMA_WRITABLE() {
        return PROCMAP_QUERY_VMA_WRITABLE;
    }
    private static final int PROCMAP_QUERY_VMA_EXECUTABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_VMA_EXECUTABLE = 4
     * }
     */
    public static int PROCMAP_QUERY_VMA_EXECUTABLE() {
        return PROCMAP_QUERY_VMA_EXECUTABLE;
    }
    private static final int PROCMAP_QUERY_VMA_SHARED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_VMA_SHARED = 8
     * }
     */
    public static int PROCMAP_QUERY_VMA_SHARED() {
        return PROCMAP_QUERY_VMA_SHARED;
    }
    private static final int PROCMAP_QUERY_COVERING_OR_NEXT_VMA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_COVERING_OR_NEXT_VMA = 16
     * }
     */
    public static int PROCMAP_QUERY_COVERING_OR_NEXT_VMA() {
        return PROCMAP_QUERY_COVERING_OR_NEXT_VMA;
    }
    private static final int PROCMAP_QUERY_FILE_BACKED_VMA = (int)32L;
    /**
     * {@snippet lang=c :
     * enum procmap_query_flags.PROCMAP_QUERY_FILE_BACKED_VMA = 32
     * }
     */
    public static int PROCMAP_QUERY_FILE_BACKED_VMA() {
        return PROCMAP_QUERY_FILE_BACKED_VMA;
    }
    private static final int IOSQE_FIXED_FILE_BIT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_FIXED_FILE_BIT = 0
     * }
     */
    public static int IOSQE_FIXED_FILE_BIT() {
        return IOSQE_FIXED_FILE_BIT;
    }
    private static final int IOSQE_IO_DRAIN_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_DRAIN_BIT = 1
     * }
     */
    public static int IOSQE_IO_DRAIN_BIT() {
        return IOSQE_IO_DRAIN_BIT;
    }
    private static final int IOSQE_IO_LINK_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_LINK_BIT = 2
     * }
     */
    public static int IOSQE_IO_LINK_BIT() {
        return IOSQE_IO_LINK_BIT;
    }
    private static final int IOSQE_IO_HARDLINK_BIT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_HARDLINK_BIT = 3
     * }
     */
    public static int IOSQE_IO_HARDLINK_BIT() {
        return IOSQE_IO_HARDLINK_BIT;
    }
    private static final int IOSQE_ASYNC_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_ASYNC_BIT = 4
     * }
     */
    public static int IOSQE_ASYNC_BIT() {
        return IOSQE_ASYNC_BIT;
    }
    private static final int IOSQE_BUFFER_SELECT_BIT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_BUFFER_SELECT_BIT = 5
     * }
     */
    public static int IOSQE_BUFFER_SELECT_BIT() {
        return IOSQE_BUFFER_SELECT_BIT;
    }
    private static final int IOSQE_CQE_SKIP_SUCCESS_BIT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_CQE_SKIP_SUCCESS_BIT = 6
     * }
     */
    public static int IOSQE_CQE_SKIP_SUCCESS_BIT() {
        return IOSQE_CQE_SKIP_SUCCESS_BIT;
    }
    private static final int IORING_OP_NOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_NOP = 0
     * }
     */
    public static int IORING_OP_NOP() {
        return IORING_OP_NOP;
    }
    private static final int IORING_OP_READV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READV = 1
     * }
     */
    public static int IORING_OP_READV() {
        return IORING_OP_READV;
    }
    private static final int IORING_OP_WRITEV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITEV = 2
     * }
     */
    public static int IORING_OP_WRITEV() {
        return IORING_OP_WRITEV;
    }
    private static final int IORING_OP_FSYNC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FSYNC = 3
     * }
     */
    public static int IORING_OP_FSYNC() {
        return IORING_OP_FSYNC;
    }
    private static final int IORING_OP_READ_FIXED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ_FIXED = 4
     * }
     */
    public static int IORING_OP_READ_FIXED() {
        return IORING_OP_READ_FIXED;
    }
    private static final int IORING_OP_WRITE_FIXED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITE_FIXED = 5
     * }
     */
    public static int IORING_OP_WRITE_FIXED() {
        return IORING_OP_WRITE_FIXED;
    }
    private static final int IORING_OP_POLL_ADD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_POLL_ADD = 6
     * }
     */
    public static int IORING_OP_POLL_ADD() {
        return IORING_OP_POLL_ADD;
    }
    private static final int IORING_OP_POLL_REMOVE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_POLL_REMOVE = 7
     * }
     */
    public static int IORING_OP_POLL_REMOVE() {
        return IORING_OP_POLL_REMOVE;
    }
    private static final int IORING_OP_SYNC_FILE_RANGE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SYNC_FILE_RANGE = 8
     * }
     */
    public static int IORING_OP_SYNC_FILE_RANGE() {
        return IORING_OP_SYNC_FILE_RANGE;
    }
    private static final int IORING_OP_SENDMSG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SENDMSG = 9
     * }
     */
    public static int IORING_OP_SENDMSG() {
        return IORING_OP_SENDMSG;
    }
    private static final int IORING_OP_RECVMSG = (int)10L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RECVMSG = 10
     * }
     */
    public static int IORING_OP_RECVMSG() {
        return IORING_OP_RECVMSG;
    }
    private static final int IORING_OP_TIMEOUT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TIMEOUT = 11
     * }
     */
    public static int IORING_OP_TIMEOUT() {
        return IORING_OP_TIMEOUT;
    }
    private static final int IORING_OP_TIMEOUT_REMOVE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TIMEOUT_REMOVE = 12
     * }
     */
    public static int IORING_OP_TIMEOUT_REMOVE() {
        return IORING_OP_TIMEOUT_REMOVE;
    }
    private static final int IORING_OP_ACCEPT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_ACCEPT = 13
     * }
     */
    public static int IORING_OP_ACCEPT() {
        return IORING_OP_ACCEPT;
    }
    private static final int IORING_OP_ASYNC_CANCEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_ASYNC_CANCEL = 14
     * }
     */
    public static int IORING_OP_ASYNC_CANCEL() {
        return IORING_OP_ASYNC_CANCEL;
    }
    private static final int IORING_OP_LINK_TIMEOUT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LINK_TIMEOUT = 15
     * }
     */
    public static int IORING_OP_LINK_TIMEOUT() {
        return IORING_OP_LINK_TIMEOUT;
    }
    private static final int IORING_OP_CONNECT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_CONNECT = 16
     * }
     */
    public static int IORING_OP_CONNECT() {
        return IORING_OP_CONNECT;
    }
    private static final int IORING_OP_FALLOCATE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FALLOCATE = 17
     * }
     */
    public static int IORING_OP_FALLOCATE() {
        return IORING_OP_FALLOCATE;
    }
    private static final int IORING_OP_OPENAT = (int)18L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_OPENAT = 18
     * }
     */
    public static int IORING_OP_OPENAT() {
        return IORING_OP_OPENAT;
    }
    private static final int IORING_OP_CLOSE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_CLOSE = 19
     * }
     */
    public static int IORING_OP_CLOSE() {
        return IORING_OP_CLOSE;
    }
    private static final int IORING_OP_FILES_UPDATE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FILES_UPDATE = 20
     * }
     */
    public static int IORING_OP_FILES_UPDATE() {
        return IORING_OP_FILES_UPDATE;
    }
    private static final int IORING_OP_STATX = (int)21L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_STATX = 21
     * }
     */
    public static int IORING_OP_STATX() {
        return IORING_OP_STATX;
    }
    private static final int IORING_OP_READ = (int)22L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ = 22
     * }
     */
    public static int IORING_OP_READ() {
        return IORING_OP_READ;
    }
    private static final int IORING_OP_WRITE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITE = 23
     * }
     */
    public static int IORING_OP_WRITE() {
        return IORING_OP_WRITE;
    }
    private static final int IORING_OP_FADVISE = (int)24L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FADVISE = 24
     * }
     */
    public static int IORING_OP_FADVISE() {
        return IORING_OP_FADVISE;
    }
    private static final int IORING_OP_MADVISE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MADVISE = 25
     * }
     */
    public static int IORING_OP_MADVISE() {
        return IORING_OP_MADVISE;
    }
    private static final int IORING_OP_SEND = (int)26L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SEND = 26
     * }
     */
    public static int IORING_OP_SEND() {
        return IORING_OP_SEND;
    }
    private static final int IORING_OP_RECV = (int)27L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RECV = 27
     * }
     */
    public static int IORING_OP_RECV() {
        return IORING_OP_RECV;
    }
    private static final int IORING_OP_OPENAT2 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_OPENAT2 = 28
     * }
     */
    public static int IORING_OP_OPENAT2() {
        return IORING_OP_OPENAT2;
    }
    private static final int IORING_OP_EPOLL_CTL = (int)29L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_EPOLL_CTL = 29
     * }
     */
    public static int IORING_OP_EPOLL_CTL() {
        return IORING_OP_EPOLL_CTL;
    }
    private static final int IORING_OP_SPLICE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SPLICE = 30
     * }
     */
    public static int IORING_OP_SPLICE() {
        return IORING_OP_SPLICE;
    }
    private static final int IORING_OP_PROVIDE_BUFFERS = (int)31L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_PROVIDE_BUFFERS = 31
     * }
     */
    public static int IORING_OP_PROVIDE_BUFFERS() {
        return IORING_OP_PROVIDE_BUFFERS;
    }
    private static final int IORING_OP_REMOVE_BUFFERS = (int)32L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_REMOVE_BUFFERS = 32
     * }
     */
    public static int IORING_OP_REMOVE_BUFFERS() {
        return IORING_OP_REMOVE_BUFFERS;
    }
    private static final int IORING_OP_TEE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TEE = 33
     * }
     */
    public static int IORING_OP_TEE() {
        return IORING_OP_TEE;
    }
    private static final int IORING_OP_SHUTDOWN = (int)34L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SHUTDOWN = 34
     * }
     */
    public static int IORING_OP_SHUTDOWN() {
        return IORING_OP_SHUTDOWN;
    }
    private static final int IORING_OP_RENAMEAT = (int)35L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RENAMEAT = 35
     * }
     */
    public static int IORING_OP_RENAMEAT() {
        return IORING_OP_RENAMEAT;
    }
    private static final int IORING_OP_UNLINKAT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_UNLINKAT = 36
     * }
     */
    public static int IORING_OP_UNLINKAT() {
        return IORING_OP_UNLINKAT;
    }
    private static final int IORING_OP_MKDIRAT = (int)37L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MKDIRAT = 37
     * }
     */
    public static int IORING_OP_MKDIRAT() {
        return IORING_OP_MKDIRAT;
    }
    private static final int IORING_OP_SYMLINKAT = (int)38L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SYMLINKAT = 38
     * }
     */
    public static int IORING_OP_SYMLINKAT() {
        return IORING_OP_SYMLINKAT;
    }
    private static final int IORING_OP_LINKAT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LINKAT = 39
     * }
     */
    public static int IORING_OP_LINKAT() {
        return IORING_OP_LINKAT;
    }
    private static final int IORING_OP_MSG_RING = (int)40L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MSG_RING = 40
     * }
     */
    public static int IORING_OP_MSG_RING() {
        return IORING_OP_MSG_RING;
    }
    private static final int IORING_OP_FSETXATTR = (int)41L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FSETXATTR = 41
     * }
     */
    public static int IORING_OP_FSETXATTR() {
        return IORING_OP_FSETXATTR;
    }
    private static final int IORING_OP_SETXATTR = (int)42L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SETXATTR = 42
     * }
     */
    public static int IORING_OP_SETXATTR() {
        return IORING_OP_SETXATTR;
    }
    private static final int IORING_OP_FGETXATTR = (int)43L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FGETXATTR = 43
     * }
     */
    public static int IORING_OP_FGETXATTR() {
        return IORING_OP_FGETXATTR;
    }
    private static final int IORING_OP_GETXATTR = (int)44L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_GETXATTR = 44
     * }
     */
    public static int IORING_OP_GETXATTR() {
        return IORING_OP_GETXATTR;
    }
    private static final int IORING_OP_SOCKET = (int)45L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SOCKET = 45
     * }
     */
    public static int IORING_OP_SOCKET() {
        return IORING_OP_SOCKET;
    }
    private static final int IORING_OP_URING_CMD = (int)46L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_URING_CMD = 46
     * }
     */
    public static int IORING_OP_URING_CMD() {
        return IORING_OP_URING_CMD;
    }
    private static final int IORING_OP_SEND_ZC = (int)47L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SEND_ZC = 47
     * }
     */
    public static int IORING_OP_SEND_ZC() {
        return IORING_OP_SEND_ZC;
    }
    private static final int IORING_OP_SENDMSG_ZC = (int)48L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SENDMSG_ZC = 48
     * }
     */
    public static int IORING_OP_SENDMSG_ZC() {
        return IORING_OP_SENDMSG_ZC;
    }
    private static final int IORING_OP_READ_MULTISHOT = (int)49L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ_MULTISHOT = 49
     * }
     */
    public static int IORING_OP_READ_MULTISHOT() {
        return IORING_OP_READ_MULTISHOT;
    }
    private static final int IORING_OP_WAITID = (int)50L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WAITID = 50
     * }
     */
    public static int IORING_OP_WAITID() {
        return IORING_OP_WAITID;
    }
    private static final int IORING_OP_FUTEX_WAIT = (int)51L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAIT = 51
     * }
     */
    public static int IORING_OP_FUTEX_WAIT() {
        return IORING_OP_FUTEX_WAIT;
    }
    private static final int IORING_OP_FUTEX_WAKE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAKE = 52
     * }
     */
    public static int IORING_OP_FUTEX_WAKE() {
        return IORING_OP_FUTEX_WAKE;
    }
    private static final int IORING_OP_FUTEX_WAITV = (int)53L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAITV = 53
     * }
     */
    public static int IORING_OP_FUTEX_WAITV() {
        return IORING_OP_FUTEX_WAITV;
    }
    private static final int IORING_OP_FIXED_FD_INSTALL = (int)54L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FIXED_FD_INSTALL = 54
     * }
     */
    public static int IORING_OP_FIXED_FD_INSTALL() {
        return IORING_OP_FIXED_FD_INSTALL;
    }
    private static final int IORING_OP_FTRUNCATE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FTRUNCATE = 55
     * }
     */
    public static int IORING_OP_FTRUNCATE() {
        return IORING_OP_FTRUNCATE;
    }
    private static final int IORING_OP_BIND = (int)56L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_BIND = 56
     * }
     */
    public static int IORING_OP_BIND() {
        return IORING_OP_BIND;
    }
    private static final int IORING_OP_LISTEN = (int)57L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LISTEN = 57
     * }
     */
    public static int IORING_OP_LISTEN() {
        return IORING_OP_LISTEN;
    }
    private static final int IORING_OP_LAST = (int)58L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LAST = 58
     * }
     */
    public static int IORING_OP_LAST() {
        return IORING_OP_LAST;
    }
    private static final int IORING_MSG_DATA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_msg_ring_flags.IORING_MSG_DATA = 0
     * }
     */
    public static int IORING_MSG_DATA() {
        return IORING_MSG_DATA;
    }
    private static final int IORING_MSG_SEND_FD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_msg_ring_flags.IORING_MSG_SEND_FD = 1
     * }
     */
    public static int IORING_MSG_SEND_FD() {
        return IORING_MSG_SEND_FD;
    }
    private static final int IORING_REGISTER_BUFFERS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS = 0
     * }
     */
    public static int IORING_REGISTER_BUFFERS() {
        return IORING_REGISTER_BUFFERS;
    }
    private static final int IORING_UNREGISTER_BUFFERS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_BUFFERS = 1
     * }
     */
    public static int IORING_UNREGISTER_BUFFERS() {
        return IORING_UNREGISTER_BUFFERS;
    }
    private static final int IORING_REGISTER_FILES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES = 2
     * }
     */
    public static int IORING_REGISTER_FILES() {
        return IORING_REGISTER_FILES;
    }
    private static final int IORING_UNREGISTER_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_FILES = 3
     * }
     */
    public static int IORING_UNREGISTER_FILES() {
        return IORING_UNREGISTER_FILES;
    }
    private static final int IORING_REGISTER_EVENTFD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_EVENTFD = 4
     * }
     */
    public static int IORING_REGISTER_EVENTFD() {
        return IORING_REGISTER_EVENTFD;
    }
    private static final int IORING_UNREGISTER_EVENTFD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_EVENTFD = 5
     * }
     */
    public static int IORING_UNREGISTER_EVENTFD() {
        return IORING_UNREGISTER_EVENTFD;
    }
    private static final int IORING_REGISTER_FILES_UPDATE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES_UPDATE = 6
     * }
     */
    public static int IORING_REGISTER_FILES_UPDATE() {
        return IORING_REGISTER_FILES_UPDATE;
    }
    private static final int IORING_REGISTER_EVENTFD_ASYNC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_EVENTFD_ASYNC = 7
     * }
     */
    public static int IORING_REGISTER_EVENTFD_ASYNC() {
        return IORING_REGISTER_EVENTFD_ASYNC;
    }
    private static final int IORING_REGISTER_PROBE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PROBE = 8
     * }
     */
    public static int IORING_REGISTER_PROBE() {
        return IORING_REGISTER_PROBE;
    }
    private static final int IORING_REGISTER_PERSONALITY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PERSONALITY = 9
     * }
     */
    public static int IORING_REGISTER_PERSONALITY() {
        return IORING_REGISTER_PERSONALITY;
    }
    private static final int IORING_UNREGISTER_PERSONALITY = (int)10L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_PERSONALITY = 10
     * }
     */
    public static int IORING_UNREGISTER_PERSONALITY() {
        return IORING_UNREGISTER_PERSONALITY;
    }
    private static final int IORING_REGISTER_RESTRICTIONS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_RESTRICTIONS = 11
     * }
     */
    public static int IORING_REGISTER_RESTRICTIONS() {
        return IORING_REGISTER_RESTRICTIONS;
    }
    private static final int IORING_REGISTER_ENABLE_RINGS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_ENABLE_RINGS = 12
     * }
     */
    public static int IORING_REGISTER_ENABLE_RINGS() {
        return IORING_REGISTER_ENABLE_RINGS;
    }
    private static final int IORING_REGISTER_FILES2 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES2 = 13
     * }
     */
    public static int IORING_REGISTER_FILES2() {
        return IORING_REGISTER_FILES2;
    }
    private static final int IORING_REGISTER_FILES_UPDATE2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES_UPDATE2 = 14
     * }
     */
    public static int IORING_REGISTER_FILES_UPDATE2() {
        return IORING_REGISTER_FILES_UPDATE2;
    }
    private static final int IORING_REGISTER_BUFFERS2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS2 = 15
     * }
     */
    public static int IORING_REGISTER_BUFFERS2() {
        return IORING_REGISTER_BUFFERS2;
    }
    private static final int IORING_REGISTER_BUFFERS_UPDATE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS_UPDATE = 16
     * }
     */
    public static int IORING_REGISTER_BUFFERS_UPDATE() {
        return IORING_REGISTER_BUFFERS_UPDATE;
    }
    private static final int IORING_REGISTER_IOWQ_AFF = (int)17L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_IOWQ_AFF = 17
     * }
     */
    public static int IORING_REGISTER_IOWQ_AFF() {
        return IORING_REGISTER_IOWQ_AFF;
    }
}

